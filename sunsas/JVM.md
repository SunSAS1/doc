# 1.3 JVM

> 作者：SunSAS
>
> **介绍：** SunSAS是SunSAS


## 1.3.1 JVM内存结构

首先我们需要明确的是**内存模型**不是指的堆，栈等等，这种应该被称之为**jvm内存结构**，而jvm内存模型指的是内存结构的抽象。

在java并发中会讲到JVM内存模型，因为它涉及到线程通信。

### 1. JVM内存模型
首先我们需要了解电脑的内存模型，JVM内存模型基于此。
![内存模型](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200724/4899162-4ef24c0bc6373591.png) 

![JVM内存模型](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200724/4899162-66736384361f6b8b.png)  
虽然java程序所有的运行都是在虚拟机中，涉及到的内存等信息都是虚拟机的一部分，但实际也是物理机的，只不过是虚拟机作为最外层的容器统一做了处理。虚拟机的内存模型，以及多线程的场景下与物理机的情况是很相似的，可以类比参考。  
Java内存模型的主要目标是定义程序中变量的访问规则。即在虚拟机中将变量存储到主内存或者将变量从主内存取出这样的底层细节。需要注意的是这里的变量跟我们写java程序中的变量不是完全等同的。这里的变量是指实例字段，静态字段，构成数组对象的元素，但是不包括局部变量和方法参数(因为这是线程私有的)。这里可以简单的认为主内存是java虚拟机内存区域中的堆，局部变量和方法参数是在虚拟机栈中定义的。但是在堆中的变量如果在多线程中都使用，就涉及到了堆和不同虚拟机栈中变量的值的一致性问题了。

- **主内存**：java虚拟机规定所有的变量(不是程序中的变量)都必须在主内存中产生，为了方便理解，可以认为是堆区。可以与前面说的物理机的主内存相比，只不过物理机的主内存是整个机器的内存，而虚拟机的主内存是虚拟机内存中的一部分。
- **工作内存**：java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的为了方便理解，可以认为是虚拟机栈。可以与前面说的高速缓存相比。线程的工作内存保存了线程需要的变量在主内存中的副本。**虚拟机规定，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量。**不同的线程之间也不能相互访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来作为中介进行传递。
 

### 2. JVM内存结构
**JDK1.8之前：**
![JDK1.8之前](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/640.jpg)  
**JDK1.8：**
![JDK1.8](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/jdk8.jpg)  

用一张图来介绍每个区域存储的内容：
![用一张图来介绍每个区域存储的内容](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/javaJVM.jpg) 

#### 2.1 **程序计数器**  
对于一个允许中的java程序而言，其中每一个线程都有它自己的pc（程序计数器）寄存器，他是在该线程启动时创建的，它既能够持有一个本地指针，也能够持有一个returnAddress，当线程执行某个java方法时，pc寄存器的内容总是下一条将被执行指令的“地址”，这里的地址可以是一个本地指针，也可以是在方法字节码中相对于该方法起始指令的偏移量。如果该线程正在执行一个本地方法，那么此时PC寄存器的值是“**undefined**”（来自《深入理解java虚拟机》）

> 内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成  
> 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

<font color=red > <b>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域(不会出OOM)。</b></font>它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
    
#### 2.2 **虚拟机栈**
与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

    Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。
    
    **每个方法**在执行时都会床创建一个**栈帧**(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
一个方法对应了一个栈桢，最底层就是main方法，假如main方法调用a方法，a就入栈，a方法再调用b方法，b就入栈。

虚拟机栈会出现两种异常：<font color=red >StackOverFlowError 和 OutOfMemoryError</font>。

- **StackOverFlowError**： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。很明显，我们写了一个错误的递归方法时，就很容易抛出此异常。
- **OutOfMemoryError**： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。
- 
**拓展知识：栈桢**  
![栈帧](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/10006199-728567b81e7abff5.png)

**局部变量表**  
局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**操作数栈**  
1. 栈桢刚创建时，里面的操作数栈是空的。
2. Java虚拟机提供指令来让操作数栈对一些数据进行入栈操作，比如可以把局部变量表里的数据、实例的字段等数据入栈。
3. 同时也有指令来支持出栈操作。
4. 向其他方法传参的参数，也存在操作数栈中。
5. 其他方法返回的结果，返回时存在操作数栈中。

其实就是做一些运算时会利用到操作数栈，计算机本身做运算就是利用栈的，下面通过一个简单的例子加深映像。
新建一个类：
```
public class Test{
	public static void main(String[] args){
		int a = 1;
		int b = 3;
		int c = (a+b)*10;
	}
}
```
`javac`编译，然后`javap -c Test.class`反编译得到：

```
public class Test {
  public Test();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: iconst_1 //iconst_1 将int类型常量1压入栈
       1: istore_1 //将int类型值存入局部变量1（赋值a）
       2: iconst_3 //将int类型常量3压入栈
       3: istore_2 // 将int类型值存入局部变量2(赋值b)
       4: iload_1 //从局部变量1中装载int类型值
       5: iload_2 //从局部变量2中装载int类型值
       6: iadd //加
       7: bipush        10    //将byte类型的数转换为int类型的数，然后压入栈。（把常量10压入栈）
       9: imul // 乘法，注意到没有第8步，因为上面的‘10’也占了一个地方，它就相当于第8步，所以这里直接跳到了9
      10: istore_3 // 将int类型值存入局部变量3(赋值c)
      11: return
}
```

**动态链接**  
Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为**动态链接**。

相当于我在0X0300H这个地址存入了一个数526，为了方便编程，我把这个给这个地址起了个别名叫A, 以后我编程的时候(运行之前)可以用别名A来暗示访问这个空间的数据，但其实程序运行起来后，实质上还是去寻找0X0300H这片空间来获取526这个数据的。

这样的符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接。

**方法返回地址**  
返回一个值给调用它的方法，**方法正常完成**发生在一个方法执行过程 中遇到了方法返回的字节码指令的时候，使用哪种返回指令取决于方法返回值的数 据类型（如果有返回值的话）。  
在这种情况，当前栈桢就被用来恢复调用者的状态，恢复局部变量表、操作数栈 和 程序计数器(pc指针)，而这个程序计数器要适当地增加，来指向下一条指令(也就是调用函数的下一句)。使调用者方法能够正常地继续执行下去，而且返回值push到了调用方法的操作数栈中。

异常时不会返回值给调用者。

#### 2.3 本地方法栈
和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务**。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <font color=red >StackOverFlowError 和 OutOfMemoryError</font> 两种异常。

#### 2.4 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

Java **堆是垃圾收集器管理的主要区域**，因此也被称作GC堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：**新生代和老年代**：再细致一点有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。  

1. **新生代**（Young Generation）  
    新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，**所有新生成的对象首先都是放在新生代**的。新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，或者存活次数足够久（默认15次），就**将存活对象直接存放到老年代**。如果老年代也满了，就会触发一次**FullGC**，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做**MinorGC**，MinorGC发生频率比较高，不一定等 Eden区满了才触发。
2. **老年代**（Old Generation）  
    老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(默认比例是2:1)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。


#### 2.5 方法区
方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。  
永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 **java.lang.OutOfMemoryError: PermGen** ，为此我们不得不对虚拟机做调优。

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

JDK 1.8 的时候，方法区被彻底移除了（JDK1.7就已经开始了），取而代之是元空间(metaspace)，元空间使用的是直接内存(native heap)。

我们可以使用参数： -XX:MetaspaceSize 来指定元数据区的大小。与永久区很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

> Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？
> - 由于 PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM
> - 移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。

#### 2.6 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。
(**方法区移至 Metaspace，字符串常量移至 Java Heap**)
![常量池](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/常量池.jpg)

#### 2.7 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。

JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

#### 2.8 元空间
JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace，中文名叫元空间。

使用本地内存有什么好处呢？  
最直接的表现就是OOM问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让 Metaspace 变得无限大显然是不现实的，因此我们也要限制 Metaspace 的大小：使用 -XX:MaxMetaspaceSize 参数来指定 Metaspace 区域的大小。JVM 默认在运行时根据需要动态地设置 MaxMetaspaceSize 的大小。

优点：
- 利用java的特性，使类和关联的元空间生命周期与类加载器相匹配。
- 线性分配
- 不单独回收（除了RedefineClasses和类加载失败）
- 不需要GC扫描和压缩
- 无需重新定位元空间对象

> 参考
>
> [深入理解JVM-内存模型（jmm）和GC](https://www.jianshu.com/p/76959115d486)  
> [ Java虚拟机运行时栈帧结构--《深入理解Java虚拟机》学习笔记及个人理解(二)
](https://www.cnblogs.com/noKing/p/8167700.html)
> [永久代为什么被移出HotSpot JVM了](https://my.oschina.net/xiaominmin/blog/3158714)      
> [听说又被 JVM 内存区域方面的面试题给虐了？看看这篇文章吧！](https://mp.weixin.qq.com/s/lryDeCfiacRxCMpzEmyoLA)


---


## 1.3.2 垃圾回收
> 基于《深入理解Java虚拟机》

垃圾回收机制是Java语言一个显著的特点，其可以有效的**防止内存泄露**、保证内存的有效使用，从而使得Java程序员在编写程序的时候不再需要考虑内存管理问题。Java 垃圾回收机制要考虑的问题很复杂，本文阐述了其三个核心问题，包括：

- **那些内存需要回收？**(对象是否可以被回收的两种经典算法: 引用计数法 和 可达性分析算法)

- **什么时候回收？** （堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC）

- **如何回收？**(三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器)


### 1. 标记算法
堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）

#### 1.1 引用计数算法：

- 判断对象的引用数量来决定对象引用是否可以被回收。
- 每个对象实例都有一个引用计数器，被引用则+1，完成引用-1
- 任何引用计数为0的对象实例可以被当做垃圾收集

优点：执行效率高，程序执行受影响较小
缺点：无法检测出**循环引用**的情况，导致内存泄漏。
![引用计数算法](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/7.png)  
如上图，就会造成循环引用。基本没有jvm使用这种算法标记回收对象。

#### 1.2 可达性分析算法
**可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。**

可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “**GC Roots**” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如下图所示。  

![可达性分析算法](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/8.png)   

**在Java中，可作为 GC Root 的对象包括以下几种：**

- 虚拟机栈(栈帧中的局部变量表)中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中Native方法引用的对象；

#### 1.3 引用
> 以下文字来源于《深入理解java虚拟机》p65

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：**当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象**。很多系统的缓存功能都符合这样的应用场景。

- **强引用**就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类引用。 只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。  
当内存空间不足，Java虚拟机宁愿抛出`OutOfMemoryError`错误，使程序异常终止，也不会靠随意回收具有强引用 对象来解决内存不足的问题。
- **软引用用来描述一些还有用，但并非必需的对象**。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。
- **弱引用也是用来描述非必需对象的**，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
- **虚引用是最弱的一种引用关系**。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。  
**jdk中直接内存的回收就用到虚引用**，由于jvm自动内存管理的范围是堆内存，而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，会在堆内存分配一个对象保存这个堆外内存的引用，这个对象被垃圾收集器管理，一旦这个对象被回收，相应的用户线程会收到通知并对直接内存进行清理工作。

#### 1.4 finalize()自我拯救
> 以下文字来源于《深入理解java虚拟机》p66

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与`GC Roots`相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。**当对象没有覆盖**`finalize()`**方法**，或者`finalize()`**方法已经被虚拟机调用过**，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为有必要执行`finalize()`方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的`Finalizer`线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。

这样做的原因是，如果一个对象在`finalize()`方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。

`finalize()`方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在`finalize()`中成功拯救自己--**只要重新与引用链上的任何一个对象建立关联即可**，譬如把自己（this关键字）赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。从代码清单中我们可以看到一个对象的`finalize()`被执行，但是它仍然可以存活。

```
/** *此代码演示了两点：
 *1.对象可以在被GC时自我拯救。
 *2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
 */
public class FinalizeEscapeGC{
    public static FinalizeEscapeGC SAVE_HOOK=null;
    public void isAlive(){
        System.out.println("yes, i am still alive：)");
    }
    @Override protected void finalize()throws Throwable{
        super.finalize();
        System.out.println("finalize mehtod executed!");
        FinalizeEscapeGC.SAVE_HOOK=this;
    }

    public static void main(String[]args)throws Throwable{
        SAVE_HOOK=new FinalizeEscapeGC(); //对象第一次成功拯救自己 SAVE_HOOK=null; System.gc();
        //因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if(SAVE_HOOK!=null){
            SAVE_HOOK.isAlive();
        }else{
            System.out.println("no, i am dead：(");
        }
        //下面这段代码与上面的完全相同，但是这次自救却失败了
        SAVE_HOOK=null;
        System.gc();
        //因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if(SAVE_HOOK!=null){
            SAVE_HOOK.isAlive();
        }else{
            System.out.println("no, i am dead：("); } 
    } 
}
```

运行结果：
        
```
finalize mehtod executed!
yes, i am still alive：)
no, i am dead：(
```
从代码清单的运行结果可以看到，`SAVE_HOOK`对象的`finalize()`方法确实被GC收集器触发过，并且在被收集前成功逃脱了。 另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的`finalize()`方法都只会被系统自动调用一次，如果对象面临下一次回收，它的`finalize()`方法不会被再次执行，因此第二段代码的自救行动失败了。

需要说明的是，不建议使用此方法拯救对象，忘了吧。





#### 1.5 回收方法区
很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的,Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集,而且在方法区中进行垃圾收集 的“性价比” 一般**比较低**:在堆中 ,尤其是在新生代中,常规应用进行一次垃圾收集一般可以回收70%〜95%的空间,而永久代的垃圾收集效率远低于此。

**永久代的垃圾收集主要回收两部分内容:废弃常量和无用的类。**

**如何判断一个常量是废弃常量？**  
假如在常量池中存在字符串"abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量”abc“就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc“会被系统清理出常量池。

**如何判断一个类是无用的类？**

需要满足以下三个条件：
- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


> 虚拟机可以对满足上述3个条件的无用类进行回收,这里说的仅仅是“可以”,而并不是和对象一样,不使用了就必然会回收。是否对类进行回收,HotSpot虚拟机提供了-Xnoclassgc 参数进行控 ,还可以使用-verbose : class以及-XX : +TraceClassLoading、 -XX : +TraceClassUnLoading查看**类加载和卸载**信息,其中-verbose : class和-XX : +TraceClassLoading可以在Product版的虚拟机中使用, -XX : +TraceClassUnLoading参数需要FastDebug版的虚拟机支持。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁 自定义ClassLoader的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出。


### 2. 垃圾回收算法
![垃圾回收算法](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/10.png) 

#### 2.1 标记-清除算法

它是最基础的收集算法，这个算法分为两个阶段，“标记”和”清除“。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它有两个不足的地方：

1. 效率问题，标记和清除两个过程的效率都不高；
2. 空间问题，标记清除后会产生大量不连续的碎片；

![标记-清除算法](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/11.jpg) 

#### 2.2 复制算法
复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种**算法适用于对象存活率低**的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。该算法示意图如下所示：

![标记-清除算法](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/12.jpg)   
> 缺点是需要额外的内存空间

**事实上，现在商用的虚拟机都采用这种算法来回收新生代**。因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。
之前说过堆的结构中有`Eden`(伊甸)，`From Survivor`，`To Survivor`。每次只用到`Eden`和其中一块`Survivor`（称之为From），当回收时，将`Eden`和`Survivor`中还存活着的对象一次地复制到另外一块`Survivor`空间上，最后清理掉Eden和刚才用过的`Survivor`空间，此时From和To就互换了。HotSpot虚拟机默认`Eden`和`Survivor`的大小比例是 8:1。其实应该是8:1:1，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。


#### 2.3 标记整理算法

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行**分配担保**，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

> 新生代中当然没有浪费50%的空间，只是浪费了10%而已。但它确实需要额外空间担保，而这个空间是由老年代来提供的。

标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，**而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存**，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代），其作用原理如下图所示：  
![标记-清除算法](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/13.png)  

> 标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。

#### 2.4 分代收集算法
分代收集算法就是说新生代采用复制算法，老年代使用标记清除算法或者标记整理算法。

分代收集算法是基于这样一个事实：不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。



> Minor GC：对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。

> Full GC：也叫 Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。

### 3. 垃圾收集器
java虚拟机规范对垃圾收集器应该如何实现没有任何规定，因为没有所谓最好的垃圾收集器出现，更不会有万金油垃圾收集器，只能是根据具体的应用场景选择合适的垃圾收集器。

垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。**不同收集器之间的连线表示它们可以搭配使用**。  
![垃圾收集器](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/14.png)    
#### 3.1 Serial收集器

Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。

新生代采用复制算法，老年代采用标记-整理算法。

![Serial收集器](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/15.jpg)

虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。

> **Stop-the-World**。Stop-the-world意味着 JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。事实上，GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。

但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它**简单而高效（与其他收集器的单线程相比）**。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器
对于运行在Client模式下的虚拟机来说是个不错的选择。

#### 3.2 ParNew收集器

**ParNew收集器其实就是Serial收集器的多线程版本**，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。

**新生代采用复制算法，老年代采用标记-整理算法。** 

![ParNew收集器](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/16.jpg)

它是许多运行**在Server模式**下的虚拟机的首要选择，除了Serial收集器外，**只有它能与CMS收集器**（真正意义上的并发收集器，后面会介绍到）**配合工作**。

#### 3.3 Parallel Scavenge收集器

Parallel Scavenge 收集器类似于ParNew 收集器。

Parallel Scavenge收集器关注点是**吞吐量**（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。**所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值**。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用复制算法，老年代采用标记-整理算法。** 

![17](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/17.jpg)

#### 3.4 Serial Old收集器

Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

**使用标记-整理算法。**

#### 3.5 Parallel Old收集器

Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。

#### 3.6 CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。

CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “**标记-清除**”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- 初始标记（CMS initial mark）： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快
- 并发标记（CMS concurrent mark）： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记（CMS remark）： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- 并发清除（CMS concurrent sweep）： 开启用户线程，同时GC线程开始对为标记的区域做清扫。

![18](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/18.jpg)

CMS主要优点：**并发收集**、**低停顿**。但是它有下面三个明显的缺点：

- **对CPU资源敏感**；
CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬如2个），那么CMS对用户程序 的影响就可能变得很大。
- **无法处理浮动垃圾**；由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次 收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“**浮动垃圾**”。
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有**大量空间碎片产生**。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续 空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完 Full GC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。

#### 3.7 G1收集器

G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.

![19](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/19.png)  
![20](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/JVM-3/20.png)


G1收集器不同于之前的收集器的一个重要特点是：**G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。**

被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：

- 并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行
- 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。
  空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的
- 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内

G1收集器的运作大致分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

#### 3.8 怎么选择垃圾收集器？

1. 优先调整堆的大小让服务器自己来选择
2. 如果内存小于100m，使用串行收集器
3. 如果是单核，并且没有停顿时间的要求，串行或JVM自己选择
4. 如果允许停顿时间超过1秒，选择并行或者JVM自己选
5. 如果响应时间最重要，并且不能超过1秒，使用并发收集器

官方推荐G1，性能高。

### 4 内存分配与回收策略
> 基于《深入理解java虚拟机》p91，稍作简化.具体也可参考[内存分配与回收策略](https://blog.csdn.net/alexwym/article/details/81948171)(就是书上的内容)

Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。对象的内存分配，往大方向上讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓存，将按线程优先在TLAB上分配。少数情况下，也可能直接分配在老年代中。

#### 4.1 对象优先在Eden分配
大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

假设vm参数如下：

```
-Xms20m // 默认堆内存 
-Xmx20m // 最大对内存
-verbose:gc 
-Xloggc:E:\eclipse\adt-bundle-windows-x86_64-20131030\gcRecorder\gc.log // gc日志输出
-Xmn10M //年轻代大小
-XX:+PrintGCDetails 
-XX:SurvivorRatio=8 // eden：survivor比例
```
先放入a,b,c三个对象，都是2mb大小，此时再放入d（4mb），会触发minor GC，但由于survivor区只有1mb，这些对象都放不进去，所以a,b,c直接进入老年代，d则分配到eden区。

#### 4.2 大对象直接分配到老年区
所谓的大对象**是指需要大量连续内存空间的Java对象**，典型的就是那种很长的字符串和数组。经常出现大对象容易导致内存还有不少空间时就提前出发垃圾收集以获取足够的连续空间来“安置”它们。（更惨的是那些短命大对象，写程序的时候应当避免）
经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。

设置参数：-XX:PretenureSizeThreshold=x。x是一个表示大小的数值，令大于这个设置值的对象直接在老年代分配。这样就避免在Eden区和两个Survivor区之间发生大量的内存复制。


#### 4.3 长期存活的对象将进入老年代

虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在Eden出现并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor中，并且年龄设为1。对象在Survivor区每熬过一次Minor GC,nianling就增加1岁，当它的年龄增加到一定程度（默认为15岁）就会进入老年代中。对象晋升老年代的年龄阈值可以通过参数-XX：MaxTenuringThreshold设置。


#### 4.4 动态对象年龄判定
虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor区中相同年龄（设年龄为age）的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。


#### 4.5 空间分配担保

在进行Minor GC前虚拟机会先**检查老年代最大可用的连续空间是否大于新生代所有对象总空间**，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。若HandlePromotionFailure=true，那么虚拟机会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。如果大于，虚拟机将尝试进行一次Minor GC，尽管这次Minor GC是有风险的。（这里的风险就是新生代如果有大量对象在minor GC后仍然存活，而survivor区不够存放，需要放入老年代中，万一没有空间，担保失败，虚拟机要重新发起一次Full GC。相当于绕了一个大圈子，浪费了时间）如果小于，或者HandlePromotionFailure=false，那这时虚拟机会放弃Minor GC，转而进行一次Full GC。在大部分情况下我们会将HandlePromotionFailure打开，为了避免Full GC过于频繁冒一点风险也是可以接受的。

> 参考
>
> [图解Java 垃圾回收机制](https://blog.csdn.net/justloveyou_/article/details/71216049?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-8.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-8.channel_param)    
> [软引用、弱引用、虚引用-他们的特点及应用场景](https://www.jianshu.com/p/825cca41d962)  



---



## 1.3.3 类加载
> 基于《深入理解Java虚拟机》

在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。

### 1. 类加载时机
![类加载时机](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/classload.jpg)

其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。

java虚拟机规范并没有约束类加载的第一个阶段：**加载**。
但对于初始化阶段，虚拟机规范严格规定了有且只有以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：
1. 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：**使用 new 关键字实例化对象**、**读取一个类的静态字段**(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、**调用一个类的静态方法**。
2. 使用 java.lang.reflect 包的方法对类进行**反射**调用的时候，如果没有初始化，则需要先触发初始化。
3. 当初始化一个类的时候，如果发现其**父类还没有进行初始化**，则需先触发其父类的初始化。
4. 当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。
5. 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。
 
前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化，称为**被动引用**。

被动引用：
- 通过子类引用父类静态字段，不会导致子类初始化
- 通过数组定义来引用类，不会触发此类的初始化，`MyClass[] m = new MyClass[10]`
- 常量在编译阶段会存入调用类的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

> 接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。


### 2. 类加载过程
#### 2.1 加载
 加载是类加载过程中的一个阶段，在加载阶段，**虚拟机需要完成以下3件事情**：

- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

关于这三点，虚拟机规范并没有具体要求，如“通过一个类的全限定名来获取定义此类的二进制字节流”没有说是从哪里获取，怎样获取，很多举足轻重的Java技术都建立在一基础之上：
- 从zip，jar等归档文件中加载.class文件
- 通过网络获取，典型应用是Applet
- 运行时计算生成，典型应用是动态代理
- 由其他文件生成，典型应用是JSP，由JSP生成对应的Class类
- 从数据库中提取，场景较少，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群中的分发

相对于类生命周期的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是**可控性最强的阶段**，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。开发人员可以重写loadClass()方法来打破双亲委派模型。

> 对于数组而言，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但是数组类的元素类型最终还是要靠类加载器去创建。

#### 2.2 连接
##### 2.2.1 验证
验证是连接阶段的第一步，这一阶段的目的是为了**确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全**。

1. **文件格式验证**：验证字节流是否符合Class文件格式的规范，如：**是否以魔数0xCAFEBABE开头**、**主、次版本号是否在当前虚拟机处理范围内**，**常量池中的常量是否有不被支持的常量类型**等等。
2. **元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；如：**这个类是否有父类**，，如果这个类不是抽象类，**是否实现了父类的抽象方法**，是否重写了父类的final方法，**是否继承了被final修饰的类**等等。
3. **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，如：操作数栈的数据类型与指令代码序列能配合工作，保证方法中的类型转换有效等等。
4. **符号引用验证**：确保解析动作能正确执行；如：通过符合引用能找到对应的类和方法，符号引用中类、属性、方法的访问性是否能被当前类访问等等。

验证阶段是非常重要的，但不是必须的。可以采用`-Xverify:none`参数来关闭大部分的类验证措施。

##### 2.2.2 准备
为**类的静态变量**分配内存，并将其赋**默认值**。

从上面一句话，可以看到两点需要注意：
- 只对static修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。而不包括实例变量，**实例变量将在对象实例化时跟着对象一起分配到Java堆中**
- 特殊情况：对**final的静态字面值常量直接赋初值**（赋初值不是赋默认值，如果不是字面值静态常量，那么会和静态变量一样赋默认值）。

##### 2.2.3 解析
将常量池中的符号引用替换为直接引用（内存地址）的过程。  
符号引用就是一组符号来描述目标，可以是任何字面量。属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。如指向方法区某个类的一个指针。

假设：一个类有一个静态变量，该静态变量是一个自定义的类型，那么经过解析后，该静态变量将是一个指针，指向该类在方法区的内存地址。

#### 2.3 初始化
类的初始化是类加载过程中的最后一步，只有类的主动使用才会导致类的初始化。（之前说的被动引用则不会）。

在准备阶段，类变量已经赋值初始值，而在初始化阶段，则根据程序员指定的主观计划去初始化类变量和其他资源，或者可以说：初始化是执行类构造器`<clint()>`方法的过程。

- 定义静态变量时指定初始值。如 private static String x="123";
- 在静态代码块里为静态变量赋值。如 static{ x="123"; } 

##### 2.3.1 clint
 clinit指的是类构造器，主要作用是在类加载过程中的初始化阶段进行执行，执行内容包括静态变量初始化和静态块的执行。
 
注意事项：
1. 如果类中没有静态变量或静态代码块，那么clinit方法将不会被生成。
2. 在执行clinit方法时，必须先执行父类的clinit方法。
3. clinit方法只执行一次。
4. static变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定。



##### 2.3.2 init
init指的是**实例构造器**，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行。

注意事项：
1. 如果类中没有成员变量和代码块，那么clinit方法将不会被生成。
2. 在执行init方法时，必须先执行父类的init方法。
3. init方法每实例化一次就会执行一次。
4. init方法先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块。


### 3. 类加载器
#### 3.1 类与类加载器
**通过一个类的全限定名来获取描述该类的二进制字节流**，这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码被称为“**类加载器**（Class Loader）”。

类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。每个类加载器都有一个独立的类名称空间，所以每个类唯一性都必须是建立在是否为同一个类加载器的前提下的。
否则，即使是两个类来源于同一个Class文件，被同一个Java虚拟机加载，**只要加载它们的类加载器不同，那这两个类就必定不相等**。
```
public class ClassLoaderOneTest {

    public static void main(String[] args) throws Exception{
        ClassLoader oneLoader = new ClassLoader() {
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try {
                    String classFileName = name.substring(name.lastIndexOf(".")+1)+".class";
                    InputStream inputStream = getClass().getResourceAsStream(classFileName);
                    if(inputStream == null){
                        return super.loadClass(name);
                    }
                    byte[] bytes = new byte[inputStream.available()];
                    inputStream.read(bytes);
                    return defineClass(name,bytes,0,bytes.length);
                }catch (IOException e){
                    throw new ClassNotFoundException(name);
                }
            }
        };
        Object object = oneLoader.loadClass("com.sunsas.ClassLoaderTest").newInstance();
        System.out.println(object.getClass());
        System.out.println("instanceof result :"+ (object instanceof com.sunsas.ClassLoaderTest));
    }
}

```

这里自定义了一个简单的加载器，它可以加载一个名为"com.sunsas.ClassLoaderTest"的类，并实例化了这个类的对象。但是输出结果如下：

```
class com.sunsas.ClassLoaderTest
instanceof result :false
```
第一句说明此对象确实是com.sunsas.ClassLoaderTest实例化的对象。但在做类型检查时却是false。这是因为在Java虚拟机中存在的两个ClassLoaderTest，**一个是由虚拟机的应用程序类加载器所加载的，另一个是由自定义的类加载器加载的**，虽然来自同一个Class文件，但在Java虚拟机中是两个互相独立的类。


#### 3.2 类加载器

从java虚拟机角度来说，只存在两种不同的类加载器：
一种是**启动类加载器**（Bootstrap ClassLoader），这个类加载器使用C++实现，是虚拟机的一部分。另外一种就是**其他类加载器**（由java语言实现，全部继承自java.lang.ClassLoader）。

从开发人员角度来看，可分为以下三类：
- **启动类加载器**（Bootstrap Class Loader）：这个类加载器复制加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。
如果需要使用引导类加载器去加载类，直接使用null代替即可。
如下是ClassLoader.getClassLoader()方法的源码：
```
/**
 * Returns the class loader for the class.  Some implementations may use
 * null to represent the bootstrap class loader. This method will return
 * null in such implementations if this class was loaded by the bootstrap
 * class loader.
 */
@CallerSensitive
public ClassLoader getClassLoader() {
    ClassLoader cl = getClassLoader0();
    if (cl == null)
        return null;
    SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
        ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
    }
    return cl;
}
```
> 如String的类加载器就是Bootstrap ClassLoader，但是打印出来就是null

- **扩展类加载器**（Extension Class Loader）:这个类加载器是在类sun.misc.launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。这是Java系统类库的扩展机制，但是在JDK9之后，被模块化能力所替代了。
- **应用程序类加载器**（Application Class Loader）:这个类加载器由sun.misc.Launcher$AppClassLoader来实现的。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如没有自定义的类加载器，这个就是默认的类加载器。

#### 3.3 双亲委派模型
parent-delegation model，双亲委派模型这个翻译并不贴切，可能早期翻译有误，搞得还以为是有父亲母亲，其实应该叫“父加载器模型”，这样好理解。

当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。
![双亲委派模型](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/1256203-20180714171531925-1737231049.png)

源码：

```
protected Class<?> loadClass(String name, boolean resolve)
            throws ClassNotFoundException{
    synchronized (getClassLoadingLock(name)) {
        // 首先检查这个classsh是否已经加载过了
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                // c==null表示没有加载，如果有父类的加载器则让父类加载器加载
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    //如果父类的加载器为空 则说明递归到bootStrapClassloader了
                    //bootStrapClassloader比较特殊无法通过get获取
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {}
            if (c == null) {
                //如果bootstrapClassLoader 仍然没有加载过，则递归回来，尝试自己去加载class
                long t1 = System.nanoTime();
                c = findClass(name);
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```
![流程](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/7634245-7b7882e1f4ea5d7d.png)

**双亲委派作用**：
1. 防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
2. 保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了（自定义一个Object就不会生效）。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。

#### 3.4 破坏双亲委派

##### 如何打破双亲委派模型？

- 自定义类加载器，重写loadClass方法；
- 使用线程上下文类加载器；

##### 双亲委派模型破坏史：
**第一次破坏**  ：

**由于双亲委派模型是在JDK1.2之后**才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法唯一逻辑就是去调用自己的loadClass()。

**第二次破坏**  ：

双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的同一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美。

如果基础类又要调用回用户的代码，那该么办？

一个典型的例子就是**JNDI**服务，JNDI现在已经是Java的标准服务，
它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。

为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：**线程上下文类加载器**(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如**JNDI、JDBC、JCE、JAXB和JBI等**。

**第三次破坏**：

双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。
**OSGi**实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：
1）将java.＊开头的类委派给父类加载器加载。
2）否则，将委派列表名单内的类委派给父类加载器加载。
3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
7）否则，类加载器失败。

**JDBC使用spi（Service Provider Inteface）中如何实现破坏双亲委派**:

![spi](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/1256203-20180714171604349-2005119436.png)
具体参考 [【JVM】浅谈双亲委派和破坏双亲委派](https://www.cnblogs.com/joemsu/p/9310226.html)

**Tomcat类加载器破坏双亲委派**：

1. 先在本地缓存中查找是否已经加载过该类(对于一些已经加载了的类，会被缓存在resourceEntries这个数据结构中)，如果已经加载即返回，否则 继续下一步。
2. 让系统类加载器(AppClassLoader)尝试加载该类，主要是为了防止一些基础类会被web中的类覆盖，如果加载到即返回，返回继续。
3. 前两步均没加载到目标类，那么web应用的类加载器将自行加载，如果加载到则返回，否则继续下一步。
4. 最后还是加载不到的话，则委托父类加载器(Common ClassLoader)去加载。
第3第4两个步骤的顺序已经违反了双亲委托机制

![spi](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200730/137084-20180526104342525-959933190.png)
具体参考 [Tomcat类加载器破坏双亲委派](https://www.cnblogs.com/fanguangdexiaoyuer/p/10213324.html)




> 参考
>
> [JVM类加载过程](https://blog.csdn.net/zhaocuit/article/details/93038538)  
> [“双亲委派模型”的无奈](https://www.cnblogs.com/getwind/p/12146064.html)


---


## 1.3.4 JVM监控调优
> 基于《深入理解Java虚拟机》第四章

说实话，这一部分并不是很重要。首先大多数的项目不需要做什么jvm调优，其次，这个东西应该建立在各种经验之上。怎么调优才是最好的，也可能你调整之后还不如原来的。
现在出现的G1收集器，基本不会出现Full GC，可调优的地方也很少。如果他出现了Full GC，很大程度就是你代码出错了。jdk9后默认使用了G1，不过在jdk8也可以设置它的GC算法为G1。

这里也只是简单说一下jvm用到的工具。


### 1. JDK命令行工具
#### 1.1 虚拟机进程状况工具
jps主要用来输出JVM中运行的进程状态信息，用于查看虚拟机运行了那些进程，并输出这些进程**LVMID**，即进程id，它是使用最频繁的一个命令，因为其它工具需要依赖jps。首先需要jps输出jvm正在运行的的进程id；然后其它工具根据进程id进行监控对应的进程运行情况。

jps 命令格式： 
`jps [options] [hostid]`

#### 1.2 jstat:虚拟机统计信息监视工具
jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或者是远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具，语法格式如下：

`jstat [ generalOption | outputOptions vmid [interval] [count]] ]`

#### 1.3 jinfo：Java配置信息工具
实时查看java配置信息工具，它也可以实时调整虚拟机各项配置参数的值。

jinfo命令格式： `jinfo [option] vmid`

#### 1.4 jmap:内存映像工具
jmap（Memory Map for Java，内存映像工具），用于生成堆转存的快照，一般是heapdump或者dump文件。如果不适用jmap命令，可以使用-XX:+HeapDumpOnOutOfMemoryError参数，当虚拟机发生内存溢出的时候可以产生快照。或者使用kill -3 pid也可以产生。jmap的作用并不仅仅是为了获取dump文件，它可以查询finalize执行队列，java堆和永久代的详细信息，如空间使用率，当前用的哪种收集器。命令格式如下：

`jmap [option] vmid`

#### 1.5 jhat：虚拟机堆转储快照分析工具

由于这个工具功能比较简陋，运行起来也比较耗时，所以这个工具不推荐使用，推荐使用MAT。

#### 1.6 jstack：Java堆栈跟踪工具
jstack用于生成虚拟机当前时刻的线程快照。语法格式如下：

`jstack [option] vmid`

### 2. JDK的可视化工具
#### 2.1 JConsole:Java监视与管理控制台
JConsole（Java Monitoring and Management Console）是一种基于JMX的可视化监视、管理工具。通过JDK/bin目录下的“jconsole.exe”启动JConsole，并可通过远程连接监视远程的服务器VM。用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强。


#### 2.2 VisualVM：多合一故障处理工具
Visual VM （All-in-One Java Troubleshooting Tool）是目前为止随JDK发布的功能最强大的运行监视和故障处理程序。 Visual VM除了提供运行监视、故障处理外，还提供了比如性能分析（Profiling）,对应用程序的实际性能影响很小，使得它可以直接应用在生产环境，这个优点是JProfiler、YourKit等第三方的性能分析工具无法比拟的.

VisualVM可以做到

- 显示虚拟机进程以及进程的配置、环境信息（jps 、jinfo）
- 监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack）
- dump以及分析堆转储快照（jmap、jhat）
- 方法级的程序运行性能分析，找出被调用最多、运行时间最长的而方法
- 离线程序快照：收集程序的运行配置、线程dump、内存dump等信息建立一个快照，方便分析
- 基于NetBeans平台开发，可安装各种各样的插件，功能强大，精华所在。


### 3. JVM调优
JVM调优基本就是GC的调优。

在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置，默认情况不做任何设置JVM会工作的很好，但对一些配置很好的Server和具体的应用必须仔细调优才能获得最佳性能。通过设置我们希望达到一些目标：
- GC的时间足够的小
- GC的次数足够的少
- 发生Full GC的周期足够的长

前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其平衡。

可以通过下面的参数打Heap Dump信息
```
-XX:HeapDumpPath
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:/usr/aaa/dump/heap_trace.txt
通过下面参数可以控制OutOfMemoryError时打印堆的信息
-XX:+HeapDumpOnOutOfMemoryError
```

1. 针对JVM堆的设置，一般可以通过**-Xms -Xmx**限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值
2. **年轻代和年老代将根据默认的比例（1：2）分配堆内存**，可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代，比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小
3. **年轻代和年老代设置多大才算合理**？这个我问题毫无疑问是没有答案的，否则也就不会有调优。我们观察一下二者大小变化有哪些影响
    - 更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC
    - 更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率

如何选择应该依赖应用程序对象生命周期的分布情况：**如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大**。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：
- 本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 
- 通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间
        
4. 在配置较好的机器上（比如多核、大内存），**可以为年老代选择并行收集算法**： -XX:+UseParallelOldGC ，默认为Serial收集
5. 线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。


**在调优之前，我们需要记住下面的原则**：
 
1. 多数的Java应用不需要在服务器上进行GC优化；
2. 多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；
3. 在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；
4. 减少创建对象的数量；
5. 减少使用全局变量和大对象；
6. GC优化是到最后不得已才采用的手段；
7. 在实际使用中，分析GC情况优化代码比优化GC参数要多得多；
 

真正熟练的使用GC调优，是建立在多次进行GC监控和调优的实战经验上的，**进行监控和调优的一般步骤为**：

1. **监控GC的状态**   
使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化；
2. **分析结果，判断是否需要优化**  
如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化；
注：**如果满足下面的指标，则一般不需要进行GC**：
   - Minor GC执行时间不到50ms；
   - Minor GC执行不频繁，约10秒一次；
   - Full GC执行时间不到1s；
   - Full GC执行频率不算频繁，不低于10分钟1次；
3. **调整GC类型和内存分配**  
如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择；
4. **不断的分析和调整**  
通过不断的试验和试错，分析并找到最合适的参数
5. **全面应用参数**  
如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。