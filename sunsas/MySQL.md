# 3.1 MySQL基础

> 作者：SunSAS
>
> **介绍：** SunSAS是SunSAS


## 3.1.1 MySQL架构

### 架构介绍
![MySQL架构](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/640.png)

MySQL大致分为4个层。
- **连接层**：最上层是一些客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
- **服务层**：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。
- **引擎层**：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。
- **存储层**：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。


MySQL的一个优势就在于存储引擎的架构上，**插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离**。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

对于上图各组件介绍：
1. **Connectors**：是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现与SQL的交互。
2. **Service & Utilities**：管理服务组件和工具组件， 提供对MySQL的集成管理，如备份(Backup),恢复(Recovery),安全管理(Security)等。
3. **Connection Pool** ：连接池组件，负责监听对客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被
创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。
4. **SQL Interface**:SQL接口组件,接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户。
5. **Parser**:查询分析器组件,首先分析SQL命令语法的合法性，并尝试将SQL命令分解成数据结构，若分解失败，则提示SQL语句不合理。
6. **Optimizer**:优化器组件,对SQL命令按照标准流程进行优化分析。
7. **Caches**:缓存。
8. **Pluggable Storage Engines**：存储引擎，这个下次再说。
9. **File System**：存储层。

### MySQl如何执行一条sql语句？

![MySQl如何执行一条sql语句](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/MySQl%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5.png)
图：极客时间。

注意**MySQL 8.0 版本开始直接将查询缓存的整块功能删掉了**。


> 参考：
>
> [有了这份MySQL精华总结，和面试官扯半天都没问题](https://mp.weixin.qq.com/s/H-lAqN5918vixP95BWGmIQ)  
> [浅谈MySQL架构体系](https://www.cnblogs.com/wangjiming/p/10410904.html)





---



## 3.1.2 MySQL存储引擎
使用哪一种引擎可以灵活选择，**一个数据库中多个表可以使用不同引擎**以满足各种性能和实际需求，使用合适的存储引擎，将会提高整个数据库的性能 。

MySQL服务器使用可插拔的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。

使用`show engine;`命令查看MySQL支持的引擎。
![MySQL支持的引擎](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png)
这里是MySQL5.7版本，可见现在默认引擎是InnoDB。


```mysql
--准确查看某个数据库中的某一表所使用的存储引擎
show table status like 'tablename'
show table status from database where name="tablename"
-- 修改存储引擎
ALTER TABLE t ENGINE = InnoDB;
-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎
SET default_storage_engine=NDBCLUSTER;
```

这里只介绍几种常见的引擎。

### MyISAM
在MySQL5.5之前，MyISAM是**默认数据库引擎**。虽然性能极佳，⽽且提供了⼤量的特性，包括全⽂索
引、压缩、空间函数等，但MyISAM**不⽀持事务和⾏级锁**，⽽且最⼤的缺陷就是崩溃后⽆法安全恢复。

### InnoDB
5.5版本之后，MySQL引⼊了InnoDB（事务性数据库引擎），对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。 
InnoDB存储引擎的特点：支持自动增长列，支持外键约束。
不过《MySQL高性能》如此说：
> 不要轻易相信“MyISAM⽐InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场
景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是⽤到了聚簇索引，或者需要访问的数据都可
以放⼊内存的应⽤。

### MEMOEY

Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在**内存**中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。 
MEMORY存储引擎的表可以选择使用BTREE索引或者HASH索引，两种不同类型的索引有其不同的使用范围 

Hash索引优点：  
Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 

Hash索引缺点： 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；

Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。

### InnoDB与MyISAM对比


对比项 | MyISAM	| InnoDB
---|---|---
主外键	| 不支持	| 支持
事务	| 不支持	| 支持
行表锁	| 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 |	行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作
缓存	| 只缓存索引，不缓存真实数据	| 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响
表空间	| 小	| 大
关注点	| 性能	| 事务
默认安装	| 是	| 是

1. InnoDB支持事务，MyISAM不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
2. InnoDB 支持外键，而 MyISAM 不支持。
3. InnoDB 是**聚簇索引**，MyISAM 是**非聚簇索引**（索引文件与数据文件分离，这样的索引称为"非聚簇索引"）。聚簇索引的文件存放在主键索引的叶子节点上，因此 **InnoDB 必须要有主键**，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
4. InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
5. **InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁**。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的又一个重要原因；



> 参考
>
> [MySQL中四种常用存储引擎的介绍](https://blog.csdn.net/qq_27028821/java/article/details/52267991)


---


## 3.1.3 MySQL索引

### 介绍
MySQL官方对索引的定义为：**索引（Index）是帮助MySQL高效获取数据的数据结构**，所以说索引的本质是：数据结构。

可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，数据库还维护者一个满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例:
![索引方式示例](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/%E7%B4%A2%E5%BC%95%E7%A4%BA%E4%BE%8B.png)
排序二叉树查找自然比线性快，时间复杂度O(logn)。当然这只是示例，MySQL使用的B+树。
> 平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。

> 索引本身也很大，不可能全部存储在内存中，一般以索引文件的形式存储在磁盘上

**优势**

提高数据检索效率，降低数据库IO成本；  
降低数据排序的成本，降低CPU的消耗。

**劣势**

索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存；  
虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息。

### 基本语法

```
-- 创建索引
CREATE [UNIQUE] INDEX indexName ON mytable(username(length));
-- 添加索引
ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName);
-- 删除
DROP INDEX [indexName] ON mytable;
-- 查看
SHOW INDEX FROM table_name\G

--这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 
-- 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
ALTER TABLE tbl_name ADD UNIQUE index_name (column_list 
-- 添加普通索引，索引值可出现多次。
ALTER TABLE tbl_name ADD INDEX index_name (column_list) 
-- (column_list)该语句指定了索引为 FULLTEXT ，用于全文索引。
ALTER TABLE tbl_name ADD FULLTEXT index_name 
```

### 索引分类
**数据结构角度**
- B+Tree索引
- Hash索引
- Full-Text全文索引
- R-Tree索引

**逻辑分类**
- 主键索引
- 普通索引（单列索引），每个索引只包含单个列，一个表可以有多个单列索引
- 联合索引（多列索引）复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
- 唯一索引
- 空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，**空间索引只能在存储引擎为MYISAM的表中创建**。

**物理存储角度**
- 聚集索引
- 非聚集索引，也叫辅助索引

区别：

1. 聚集索引在叶子节点存储的是表中的数据
2. 非聚集索引在叶子节点存储的是主键和索引列
3. 使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。(拿到主键再查找这个过程叫做**回表**)



### 基本存储结构
MySQL的基本存储结构是**页**(记录都存在页里边)：
![页](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/164c6d7a53a7920b.png)
页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 innodb_page_size 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：`show variables like 'innodb_page_size';`
![页2](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/164c6d7a53b78847.png)
- 各个数据页可以组成一个**双向链表**。
- 而**每个数据页中的记录又可以组成一个单向链表** 。
- 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
- 以其他列(非主键)作为搜索条件：**只能从最小记录**开始依次遍历单链表中的每条记录。


### B-Tree
注意B树就是B-树，把他称之为“B减树”是不正确的，他就是一个横杠而已。  
B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。
一棵m阶的B-Tree有如下特性：
1. 每个节点最多有m个孩子
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。
3. 若根节点不是叶子节点，则至少有2个孩子
4. 所有叶子节点都在同一层，且不包含其它关键字信息
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1
7. ki(i=1,…n)为关键字，且关键字升序排序
8. Pi(i=1,…n)为指向子树根节点的指针。
9. P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

一个3阶的B-Tree：
![B-Tree](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/B-Tree.png)
![B-Tree](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/B-Tree4.JPG)
类似排序二叉树，要求父节点值比左节点的都大，比右节点的都小。  
每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字（例如一层的17，35）和三个指向子树根节点的指针（p1,p2,p3），指针存储的是子节点所在磁盘块的地址。由定义可知根节点中p1指向的范围应该小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

查找关键字29的过程：
1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。
3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。
5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29。

分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘**I/O操作是影响整个B-Tree查找效率的决定因素**。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。

### B+Tree
B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构,InnoDB 存储引擎是用 B+Tree 实现其索引结构。
由于B-Tree每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会**导致B-Tree的深度较大**，增大查询时的磁盘I/O次数，进而影响查询效率。B+Tree的不同是**所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息**。这样就可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
1. 非叶子节点只存储键值信息；
2. **所有叶子节点之间都有一个链指针**；
3. 数据记录都存放在叶子节点中。


由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：
![B+Tree](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/B%2BTree.png)
![B+Tree](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/B%2Btree5.JPG)

B+树的头指针有两个，一个指向根节点，另一个指向关键字最小的元素(上图DATA)，因此B+树有两种遍历的方式：
1. 从根节点开始随机查询
2. 从最小关键词顺序查询

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3 ）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，**b+数是按照从左到右的顺序来建立搜索树**的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即**索引的最左匹配特性**。

> **为什么Mysql索引要用B+树不是B树**？
> 
> 用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。

还有一个**B*树**：
B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。
![B*树](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/BxingTree6.JPG)
### 主键索引与辅助索引
#### MyISAM
MyISAM引擎的索引文件和数据文件是分离的。MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址。**索引文件与数据文件分离，这样的索引称为"非聚簇索引"**。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。

![MyISAM](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/MyISAM%E7%B4%A2%E5%BC%95.png)
在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。

主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。

通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据（回表）。辅助索引类似。

#### InnoDB

InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，**InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。**

**主键索引**

InnoDB索引是**聚集索引**，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。
![InnoDB](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/InnoDB%E7%B4%A2%E5%BC%95.png)

**辅助（非主键）索引**

我们以示例中学生表中的name列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。

这就意味着，对name列进行条件搜索，需要两个步骤：

① 在辅助索引上检索name，到达其叶子节点获取对应的主键；

② 使用主键在主索引上再进行对应的检索操作。

这也就是所谓的“**回表查询**”

![辅助（非主键）索引](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/InnoDB%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png)

InnoDB 存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表**生成一个隐含字段作为主键**，并且这个字段长度为6个字节，类型为整型。

> **为什么推荐使用整型自增主键而不是选择UUID？**  
> 1.  UUID是字符串，比整型消耗更多的存储空间;  
> 2. 在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；
> 3. 自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id > 5 && id < 20的条件查询语句。
> 4. 在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。
    
> **为什么非主键索引结构叶子节点存储的是主键值？**
>
> 保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。



### Hash索引
主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。
![Hash索引](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/Hash%E7%B4%A2%E5%BC%95.jpg)
检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有**Memory**等。

**劣势：**

- 哈希索引也没办法利用索引完成**排序**
- 不支持**最左匹配原则**
- 在有大量重复键值情况下，哈希索引的效率也是极低的---->哈希碰撞问题。
- 不支持**范围查询**

> **为何不采用Hash方式？**
>
> 因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。
>
> 哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。

MySQL目前有Memory引擎和NDB引擎支持Hash索引。
**InnoDB是自适应哈希索引**的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）


### full-text全文索引
全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。

它用于替代效率较低的**LIKE模糊匹配**操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。

同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。


### R-Tree空间索引
空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型


### 常见问题
**哪些情况需要创建索引**
- 主键自动建立唯一索引
- 频繁作为查询条件的字段
- 查询中与其他表关联的字段，外键关系建立索引
- 单键/组合索引的选择问题，高并发下倾向创建组合索引
- 查询中排序的字段，排序字段通过索引访问大幅提高排序速度
- 查询中统计或分组字段

**哪些情况不需要创建索引**
- 表记录太少
- 经常增删改的表
- 数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）
- 频繁更新的字段不适合创建索引（会加重IO负担）
- where条件里用不到的字段不创建索引


**MySQL高效索引**

**覆盖索引**（Covering Index）,或者叫索引覆盖， 也就是平时所说的不需要**回表**操作。
一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。  
就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。  
譬如：现在我创建了索引(username,age)，在查询数据的时候：select username , age from user where username = 'Java3y' and age = 20。
很明显地知道，我们上边的查询是走索引的，并且，要查询出的列在叶子节点都存在！所以，就不用回表了。

**索引最左匹配原则**

索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即联合索引。
如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），**遇到范围查询**(>、<、between、like左匹配)等就不能进一步匹配了，后续退化为**线性查找**。
> 如有索引(a, b, c, d)，查询条件a = 1 and b = 2 and c > 3 and d = 4，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是相等的情况，不能是范围匹配)

因此，列的排列顺序决定了可命中索引的列数。

**注意事项**
1. **最左前缀匹配原则**。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配。
2. 尽量选择**区分度高**的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
3. **索引列不能参与计算**，尽量保持列“干净”。比如，FROM_UNIXTIME(create_time) = '2016-06-06' 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time = UNIX_TIMESTAMP('2016-06-06')。
4. 尽可能的**扩展索引**，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
5. 单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL**只能使用一个索引**，会从多个单列索引中选择一个限制最为严格的索引。


> 参考：
>
> [有了这份MySQL精华总结，和面试官扯半天都没问题！ ](https://mp.weixin.qq.com/s/H-lAqN5918vixP95BWGmIQ)
>
>[数据库两大神器【索引和锁】](https://juejin.im/post/5b55b842f265da0f9e589e79)
>
> [B树、B-树、B+树与红黑树](https://blog.csdn.net/qq_17612199/article/details/50944413?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)