## 1 代码简洁之道

> 作者：SunSAS
>
> **介绍：** SunSAS是SunSAS

### 1.1 JAVA 8 Sream
说实话学了这么久的java，还不知道stream啥玩意，主要平时也很见到。

*Java 8 引入了全新的 Stream API，可以使用声明的方式来处理数据，极大地方便了集合操作，让我们可以使用更少的代码来实现更为复杂的逻辑。*

当然你完全可以用for循环去写这些的逻辑，不过就会感觉有些low了。

#### Stream对象的创建
Stream对象分为两种，一种串行的流对象，一种并行的流对象：


```java
// permissionList指一个列表 
// 为集合创建串行流对象 
Stream<UmsPermission> stream = permissionList.stream(); 
// 为集合创建并行流对象 
tream<UmsPermission> parallelStream = permissionList.parallelStream();
```


串行就是单线程，并行是多线程一起处理，所以并行比较复杂，咱们就搞点简单的。

参考[java8-stream 4 聊聊串行与并行](https://www.jianshu.com/p/933547a77fdf)

#### filter
对Stream中的元素进行过滤操作，当设置条件返回true时返回相应元素。


```java
// 获取权限类型为目录的权限
List<UmsPermission> dirList = permissionList.stream() 
    .filter(permission -> permission.getType() == 0) 
    .collect(Collectors.toList());
```




```java
List<UmsPermission> dirList = new ArrayList<>(permissionList.size());
for(int i = 0; i < permissionList.size(); i++){
    if(permission[i].getType == 0){
        dirList.add(permission[i]); 
    }
}
```


优雅了很多了，上面一句代码搞定，虽然比较长。以前全部是用for循环搞得，简直丑陋。

#### map
对Stream中的元素进行转换处理后获取。 我们经常会有这样的需求：需要把某些对象的id提取出来，然后根据这些id去查询其他对象，这时可以使用此方法。

```java
// 获取所有权限的id组成的集合 
List<Long> idList = permissionList.stream() 
    .map(permission -> permission.getId()) 
    .collect(Collectors.toList());
```



// 来自项目真实代码

```java
List<Long> idList = new ArrayList<>(associationRecordDos.size());
for(AssociationRecordDo associationRecord : associationRecordDos){
    idList.add(associationRecord.getRelationId());
}
```



#### limit
从Stream中获取指定数量的元素。
// 获取前5个对象组成的集合

```java
List<UmsPermission> firstFiveList = permissionList.stream() 
    .limit(5)
    .collect(Collectors.toList());
```



#### count
仅获取Stream中元素的个数。一般和filter连用

```java
// count操作：获取所有目录权限的个数 
long dirPermissionCount = permissionList.stream() 
    .filter(permission -> permission.getType() == 0) 
    .count();
```



#### sorted
对Stream中元素按指定规则进行排序。
// 将所有权限按先目录后菜单再按钮的顺序排序 

```java
List<UmsPermission> sortedList = permissionList.stream() 
    .sorted((permission1,permission2)->{return permission1.getType().compareTo(permission2.getType());}) 
    .collect(Collectors.toList());
```



#### skip
跳过指定个数的Stream中元素，获取后面的元素。
// 跳过前5个元素，返回后面的 

```java
List<UmsPermission> skipList = permissionList.stream() 
    .skip(5) 
    .collect(Collectors.toList());
```



#### 用collect方法将List转成map
可以先把该List转换为以id为key的map结构，然后再通过map.get(id)来获取对象，这样比较方便。

```java
// 将权限列表以id为key，以权限对象为值转换成map 
Map<Long, UmsPermission> permissionMap = permissionList.stream() 
    .collect(Collectors.toMap(permission -> permission.getId(), permission -> permission));
```



一个例子：

```java
@Override
public List<UmsPermissionNode> treeList() {
    List<UmsPermission> permissionList = permissionMapper.selectByExample(new UmsPermissionExample());
    List<UmsPermissionNode> result = permissionList.stream()
            .filter(permission -> permission.getPid().equals(0L))
            .map(permission -> covert(permission, permissionList)).collect(Collectors.toList());
    return result;
}

/**
 * 将权限转换为带有子级的权限对象
 * 当找不到子级权限的时候map操作不会再递归调用covert
 */
private UmsPermissionNode covert(UmsPermission permission, List<UmsPermission> permissionList) {
    UmsPermissionNode node = new UmsPermissionNode();
    BeanUtils.copyProperties(permission, node);
    List<UmsPermissionNode> children = permissionList.stream()
            .filter(subPermission -> subPermission.getPid().equals(permission.getId()))
            .map(subPermission -> covert(subPermission, permissionList)).collect(Collectors.toList());
    node.setChildren(children);
    return node;
}
```

***
### 1.2 Java8 Optional

Optional可以优雅的解决 NullPointException 的问题

#### 一：常用API
##### 1：创建Optional对象

```java
// 参数不能是null  
Optional<Integer> optional1 = Optional.of(1);

  
// 参数可以是null  
Optional<Integer> optional2 = Optional.ofNullable(null);  
```
##### 2：isPresent判断值是否存在

```java
//基本不用，它应该被设为一个私有方法
optional.isPresent()
```


##### 3：orElse(value)
如果optional对象保存的值不是null，则返回原来的值，否则返回value
##### 4：map(Function)
对Optional中保存的值进行函数运算，并返回新的Optional(可以是任何类型)
##### 5：flatMap()
flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。
___
#### 二：Optional使用

```java
public String getUsername(User u){
    Optional<User> user = Optional.ofNullable(u) 
    if (user.isPresent()) {
        return user.getName();
    } else {
        return "Unknown";
    }
}
```






