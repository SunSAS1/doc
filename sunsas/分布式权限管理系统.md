# 5.2 分布式后台权限管理系统

> 作者：SunSAS
>
> **介绍：** 此文档为项目开发介绍文档，不属于技术文档

## 5.2.1. 简介

> 这是一个微服务项目，帮助理解学习Spring Cloud，原作者鸟哥，[Spring Cloud 微服务权限系统搭建教程](https://www.kancloud.cn/mrbird/spring-cloud),如果想要详细了解此项目，建议去购买，我这里只是简略版本。

![项目架构图](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200817/uS4Xin.png)

使用到了以下技术：
- eureka
- zuul
- feign
- Sleuth
- elk
- dokcer


---


## 5.2.2. 项目基础框架

### 2.1 总览
架构中，主要包含了以下节点：

- FEBS-Register：微服务注册中心，用于统一控制各个微服务实例的注册与发现；
- FEBS-Gateway：微服务网关，统一处理外部请求，是客户端和众多微服务连接的桥梁；
- FEBS-Auth：微服务认证服务器，用于令牌（Token）生成和令牌校验，是整个权限系统的核心所在；
- FEBS-Server-System：微服务提供者（资源服务器）A，对外提供系统模块的CRUD服务；
- FEBS-Server-Test：微服务提供者（资源服务器）B。

本质上FEBS-Server-Test和FEBS-Server-System没有区别，构建FEBS-Server-Test的目的主要有如下三点：

- 演示一台认证服务器和多台资源服务器之间如何交互；
- 微服务间如何通过Feign Client来互相访问受保护的资源；
- 演示如何往FEBS Cloud微服务权限系统中接入自己的微服务模块；

### 2.2 父模块和通用模块
#### 2.2.1 父模块

使用IDEA创建一个Maven项目，SDK使用JDK1.8。

`ArtifactId:febs-cloud`其余随意

下一步建议按照下图来，包括文件夹，尤其重要，不然后面容易找不到子项目。

![parent](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200817/e2D36A.png)

此项目为父项目，所以可以把src目录删了。修改pom.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.sunsas</groupId>
    <artifactId>febs-cloud</artifactId>
    <version>1.0-SNAPSHOT</version>
    <modules>
        <module>../febs-common</module>
        <module>../febs-register</module>
        <module>../febs-auth</module>
        <module>../febs-gateway</module>
        <module>../febs-server</module>
        <module>../febs-monitor</module>
    </modules>
    <packaging>pom</packaging>

    <name>FEBS-Cloud</name>
    <description>FEBS-Cloud：Spring Cloud，Spring Security OAuth2 微服务权限管理系统</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.6.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <spring-cloud.version>Greenwich.SR1</spring-cloud.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```
> 中间的module是子项目，当然一开始是没有的，为防止报错，可以先注释了。

#### 2.2.2 通用模块
通用模块主要用于定义一些各个微服务通用的实体类，工具类或者第三方依赖等。

**注意这里要创建module**  
`File->New->Module`  

同样是新建Maven项目

![common1](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200817/QQ图片20200817174805.png)

![common2](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200817/e2DUk8.png)

可知febs-common和febs-cloud都位于febs目录下，它们在目录结构上是平级的关系


```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>febs-cloud</artifactId>
        <groupId>com.sunsas</groupId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../febs-cloud/pom.xml</relativePath>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>febs-common</artifactId>
    <name>FEBS-Common</name>
    <description>FEBS-Common通用模块</description>

    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.51</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-oauth2</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.1.2</version>
        </dependency>
        <dependency>
            <groupId>de.codecentric</groupId>
            <artifactId>spring-boot-admin-starter-client</artifactId>
            <version>2.1.6</version>
        </dependency>
    </dependencies>
</project>
```

IDEA中` <relativePath>../febs-cloud/pom.xml</relativePath>`可能会报红，不过不用管。

这些依赖可以先不加，到后面使用时候再说。
> lombok需要安装插件

### 2.3 服务注册中心

同**通用模块**，新建Module，不过这次不是Maven项目，选择**Spring Initialzr**

![register1](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200817/e2rfVP.png)

![register1](https://sunsasdoc.oss-cn-hangzhou.aliyuncs.com/image/20200817/e2rhUf.png)

还是注意文件夹，与其余两个平级关系。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <artifactId>febs-cloud</artifactId>
        <groupId>com.sunsas</groupId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../febs-cloud/pom.xml</relativePath>
    </parent>
    <groupId>com.sunsas</groupId>
    <artifactId>febs-register</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>febs-register</name>
    <description>FEBS-Cloud服务注册中心</description>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
        <!--<dependency>-->
        <!--    <groupId>org.springframework.cloud</groupId>-->
        <!--    <artifactId>spring-cloud-starter-security</artifactId>-->
        <!--</dependency>-->
        <!--<dependency>-->
        <!--    <groupId>de.codecentric</groupId>-->
        <!--    <artifactId>spring-boot-admin-starter-client</artifactId>-->
        <!--    <version>2.1.6</version>-->
        <!--</dependency>-->
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```
注释的部分是安全组件和监控组件，暂时不用。

启动类加上`@EnableEurekaServer`标识开启Eureka服务端功能。

配置文件：

```yml
server:
  port: 8001
  servlet:
    context-path: /register

spring:
  application:
    name: FEBS-Register
  security:
    user:
      name: febs
      password: 123456
  boot:
    admin:
      client:
        url: http://${febs-monitor-admin}:8401
        username: febs
        password: 123456
# spring.boot.admin.client.url指定了SBA服务端地址；
# spring.boot.admin.client.username对应SBA服务端的用户名；
# spring.boot.admin.client.password对应SBA服务端的密码；
# info.**配置了SBA客户端的名称，描述和版本信息；
# management.endpoints.web.exposure.include='*'表示将SBA客户端的所有监控端点都暴露给SBA服务端；
# management.endpoint.health.show-details表示总是展示详细的健康信息。
info:
  app:
    name: ${spring.application.name}
    description: "@project.description@"
    version: "@project.version@"

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: ALWAYS

eureka:
  instance:
    hostname: ${febs-register}
  client:
    # 表示是否将服务注册到Eureka服务端，由于我们这里是单节点的Eureka服务端，所以这里指定false
    register-with-eureka: false
    # 表示是否从Eureka服务端获取服务信息，因为这里是单节点的Eureka服务端，并不需要从别的Eureka服务端同步服务信息，所以这里设置为false；
    fetch-registry: false
    # 微服务更新实例信息的变化到Eureka服务端的间隔时间，单位为秒，这里指定为30秒（这就是微服务启动后，要过一会才能注册到Eureka服务端的原因）。
    instance-info-replication-interval-seconds: 30
    # 指定Eureka服务端的地址，这里为当前项目地址，即 http://localhost:8001/register/eureka/
    serviceUrl:
      defaultZone: http://${spring.security.user.name}:${spring.security.user.password}@${eureka.instance.hostname}:${server.port}${server.servlet.context-path}/eureka/
```

关注下面的eureka配置，这里使用了启动参数，还设置了用户密码，一开始是没有的，关于**Security**下面再讲。例如改写`hostname: localhost`  
`defaultZone: http://${eureka.instance.hostname}:${server.port}${server.servlet.context-path}/eureka/`

还可以自定义个**启动banner**，就是启动时控制台最开始出现的图标。resource目录下新建banner.txt文件：

```
|------------------------------|
|    ____  ____  ___   __      |
|   | |_  | |_  | |_) ( (`     |
|   |_|   |_|__ |_|_) _)_)     |
|                              |
|   ${spring.application.name}              |
|   Spring-Boot: ${spring-boot.version} |
|------------------------------|

```

#### Securtiy保护微服务注册中心
现在服务注册中心没有防护，只要知道地址就能注册进来。所以加入Security，这样需要用户名和密码才能注册到中心去。

依赖上面已经有了，配置也说了：就只配置了`name: febs，password: 123456`

增加配置类(新建包configure)

```java
package com.sunsas.febsregister.configure;

@EnableWebSecurity
public class FebsRegisterWebSecurityConfigure extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //Spring Security 默认开启了所有 CSRF 攻击防御,需要禁用 /eureka 的防御。
        http.csrf().ignoringAntMatchers("/eureka/**")
                    .and()
                    .authorizeRequests().antMatchers("/actuator/**").permitAll();
        super.configure(http);
    }
}
```
`and()`后面的可以先不管。

现在Eureka服务端受保护，需要正确的用户名和密码才能访问.  
所以`defaultZone: http://${spring.security.user.name}:${spring.security.user.password}@${eureka.instance.hostname}:${server.port}${server.servlet.context-path}/eureka/`
添加了用户名和密码


### 2.4 Auth认证服务
结合Spring Cloud OAuth和Spring Cloud Security搭建一个统一给微服务发放访问令牌的认证服务器febs-auth。

#### 2.4.1 搭建
和register一样，新建module，选择Spring Initializr,区别就是名字由febs-register换为febs-auth。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <artifactId>febs-cloud</artifactId>
        <groupId>com.sunsas</groupId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../febs-cloud/pom.xml</relativePath>
    </parent>
    <groupId>com.sunsas</groupId>
    <artifactId>febs-auth</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>febs-auth</name>
    <description>FEBS-Cloud认证服务器</description>

    <dependencies>
        <dependency>
            <groupId>com.sunsas</groupId>
            <artifactId>febs-common</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>dynamic-datasource-spring-boot-starter</artifactId>
            <version>2.5.4</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <dependency>
            <groupId>com.github.whvcse</groupId>
            <artifactId>easy-captcha</artifactId>
            <version>1.6.2</version>
        </dependency>
        <dependency>
            <groupId>net.logstash.logback</groupId>
            <artifactId>logstash-logback-encoder</artifactId>
            <version>6.1</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```
这里依赖了**common**模块，其余依赖和本小节关系不大。
> common模块中依赖引入的redis，Eureka-client开始用起来了

启动类加注解`@EnableDiscoveryClient`

配置文件：

```yml
server:
  port: 8101

spring:
  application:
    name: FEBS-Auth
  redis:
    database: 0
    host: ${redis.url}
    port: 6379
    lettuce:
      pool:
        min-idle: 8
        max-idle: 500
        max-active: 2000
        max-wait: 10000
    timeout: 5000
  datasource:
    dynamic:
      hikari:
        connection-timeout: 30000
        max-lifetime: 1800000
        max-pool-size: 15
        min-idle: 5
        connection-test-query: select 1
        pool-name: FebsHikariCP
      primary: base
      datasource:
        base:
          driver-class-name: com.mysql.cj.jdbc.Driver
          username: root
          password: 123456
          url: jdbc:mysql://${mysql.url}:3306/febs_cloud_base?useUnicode=true&characterEncoding=UTF-8&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=GMT%2b8
  boot:
    admin:
      client:
        url: http://${febs-monitor-admin}:8401
        username: febs
        password: 123456

info:
  app:
    name: ${spring.application.name}
    description: "@project.description@"
    version: "@project.version@"

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: ALWAYS

eureka:
  instance:
    # 向Eureka 服务端发送心跳的间隔时间，单位为秒，用于服务续约。这里配置为20秒，即每隔20秒向febs-register发送心跳，表明当前服务没有宕机
    lease-renewal-interval-in-seconds: 20
  client:
    # 为true时表示将当前服务注册到Eureak服务端
    register-with-eureka: true
    # 为true时表示从Eureka 服务端获取注册的服务信息
    fetch-registry: true
    # 新实例信息的变化到Eureka服务端的间隔时间，单位为秒
    instance-info-replication-interval-seconds: 30
    # 默认值为30秒，即每30秒去Eureka服务端上获取服务并缓存，这里指定为3秒的原因是方便开发时测试，实际可以指定为默认值即可
    registry-fetch-interval-seconds: 3
    serviceUrl:
      defaultZone: http://febs:123456@${febs-register}:8001/register/eureka/


# mybatis-plus.type-aliases-package，指定别名扫描路径，这个路径后续在febs-common模块里定义，该路径下的实体类将自动配置别名，默认为类名首字母小写。配置别名后，便可以直接在MyBatis XML文件里使用了；
# mybatis-plus.mapper-locations指定MyBatis XML文件路径；
# mybatis-plus.configuration.jdbc-type-for-null，指定为null，否则再插入空值时会报“无效的列类型”错误；
# mybatis-plus.configuration.global-config.banner设置为false关闭MyBatis Plus Banner打印。
mybatis-plus:
  type-aliases-package: com.sunsas.febs.common.entity.system
  mapper-locations: classpath:mapper/*.xml
  configuration:
    jdbc-type-for-null: null
  global-config:
    banner: false
```

现在只要关心eureka的配置，其余不管。

我们需要定义一个WebSecurity类型的安全配置类FebsSecurityConfigure，新增configure包，然后在configure包下新增FebsSecurityConfigure类：

```java
/**
 * 功能描述: <br>FebsSecurityConfigure用于处理/oauth开头的请求，Spring Cloud OAuth内部定义的获取令牌，
 * 刷新令牌的请求地址都是以/oauth/开头的，也就是说FebsSecurityConfigure用于处理和令牌相关的请求；
 * @Order(2)用来提高优先级，原因是保证此过滤器在FebsResourceServerConfigure先处理（FebsResourceServerConfigure的顺序默认是3）。
 */
@Order(2)
@EnableWebSecurity
public class FebsSecurityConfigure extends WebSecurityConfigurerAdapter {
    // 注释1
    @Autowired
    private FebsUserDetailService userDetailService;
    // 注释2
    @Autowired
    private PasswordEncoder passwordEncoder;
    // 注释3
    @Autowired
    private ValidateCodeFilter validateCodeFilter;

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception{
        return super.authenticationManagerBean();
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 通过http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)代码，
        // 将ValidateCodeFilter过滤器添加到了UsernamePasswordAuthenticationFilter过滤器前。
        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                .requestMatchers()
                .antMatchers("/oauth/**")
                .and()
                .authorizeRequests()
                .antMatchers("/oauth/**").authenticated()
                .and()
                .csrf().disable();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailService).passwordEncoder(passwordEncoder);
    }
}
```

**注释1**：`FebsUserDetailService`，一个用于校验用户名密码的类，新增service包：

```java
// 初始版本，模拟了一个用户
@Service
public class FebsUserDetailService implements UserDetailsService {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        FebsAuthUser user = new FebsAuthUser();
        user.setUsername(username);
        user.setPassword(this.passwordEncoder.encode("123456"));

        return new User(username, user.getPassword(), user.isEnabled(),
                user.isAccountNonExpired(), user.isCredentialsNonExpired(),
                // 模拟一个user:add权限。
                user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList("user:add"));
    }
}
```
`FebsAuthUser`为POJO类：

```java

// 注意是common模块下的
package com.sunsas.febs.common.entity;

/**
 * 功能描述: <br>从数据库中查询出来的用户
 * @Author: Lenovo
 * @Date: 2019/11/15 17:03
 */
@Data
@EqualsAndHashCode(callSuper = true)
public class FebsAuthUser extends User {
    private static final long serialVersionUID = -1748289340320186418L;

    private Long userId;

    private String avatar;

    private String email;

    private String mobile;

    private String sex;

    private Long deptId;

    private String deptName;

    private String roleId;

    private String roleName;

    private Date lastLoginTime;

    private String description;

    private String status;

    public FebsAuthUser(String username, String password, Collection<? extends GrantedAuthority> authorities) {
        super(username, password, authorities);
    }

    public FebsAuthUser(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection<? extends GrantedAuthority> authorities) {
        super(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, authorities);
    }
}

```


**注释2**：这里是在`febs-common`模块把BCryptPasswordEncoder注入到容器中（`com.sunsas.febs.common.configure.FebsServerProtectConfigure`），现阶段可以直接创建`BCryptPasswordEncoder`：

```
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(userDetailService).passwordEncoder(passwordEncoder());
}
```

**注释3**：这个是**验证码**相关的过滤器，可以先不加，包括下面的`http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)`删掉。

认证服务器本身也可以对外提供REST服务，比如通过Token获取当前登录用户信息，注销当前Token等，所以它也是一台资源服务器。于是我们需要定义一个资源服务器的配置类，在configure包下新建`FebsResourceServerConfigure`

```java
@Configuration
@EnableResourceServer
public class FebsResourceServerConfigurer extends ResourceServerConfigurerAdapter {
    
    // 这两个是权限不足，或token错误的拒绝策略，详见下章 异常处理
    @Autowired
    private FebsAccessDeniedHandler accessDeniedHandler;
    @Autowired
    private FebsAuthExceptionEntryPoint exceptionEntryPoint;
    // 这个是读取的配置信息，解析到anonUrls
    @Autowired
    private FebsAuthProperities properities;

    @Override
    public void configure(HttpSecurity http) throws Exception {
        // 从配置文件读取白名单路径
        String[] anonUrls = StringUtils.splitByWholeSeparatorPreserveAllTokens(properities.getAnonUrl(),",");

        http.csrf().disable()
                .requestMatchers().antMatchers("/**")
                .and()
                .authorizeRequests()
                // 设置白名单
                .antMatchers(anonUrls).permitAll()
                .antMatchers("/**").authenticated()
                .and().httpBasic();
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) {
        resources.authenticationEntryPoint(exceptionEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);
    }
}
```
关于白名单路径，我们现在还没有，所以暂时可以删了。

`requestMatchers().antMatchers("/**")`的配置表明该安全配置对所有请求都生效

> 上面说到`FebsResourceServerConfigure`的order默认是3，其实是从它的注解`@EnableResourceServer`引入的配置类`ResourceServerConfiguration`看到的。

我们**指定`FebsSecurityConfigure`的优先级为2，高于`FebsResourceServerConfigure`**,这样以/oauth/开头的请求由`FebsSecurityConfigure`过滤器链处理，剩下的其他请求由`FebsResourceServerConfigure`过滤器链处理。

接着我们定义一个和**认证服务器相关的安全配置类**。在configure包下新建`FebsAuthorizationServerConfigure`,继承 `AuthorizationServerConfigurerAdapter`

作为认证服务器，OAuth2 协议里的其他几个角色他都要知道，认证服务器都要知道各个角色都是谁，他们各自的特征是什么。

1. 要知道有哪些**客户端应用**来申请令牌
2. 要知道有哪些**合法的用户**
3. 要知道发出去的令牌，能够访问哪些**资源服务器**

详细参考[Spring Cloud微服务安全实战_4-4_OAuth2协议与微服务安全](https://www.cnblogs.com/lihaoyang/p/12045480.html)

查看`AuthorizationServerConfigurerAdapter`源码：

```java
public class AuthorizationServerConfigurerAdapter implements AuthorizationServerConfigurer {

    // 配置资源服务器校验token的规则
	@Override
	public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
	}
	
    // 配置客户端应用的信息，让认证服务器知道有哪些客户端应用来申请令牌。
	@Override
	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
	}

    // 配置用户信息
	@Override
	public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
	}
}
```

`FebsAuthorizationServerConfigure`:
```java
// 初版
@Configuration
@EnableAuthorizationServer
public class FebsAuthorizationServerConfigure extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private AuthenticationManager authenticationManager;
    @Autowired
    private RedisConnectionFactory redisConnectionFactory;
    @Autowired
    private FebsUserDetailService userDetailService;
    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()//配置在内存里，后面修改为数据库里
        //~============== 注册【客户端应用】,使客户端应用能够访问认证服务器 ===========
                .withClient("febs")
                .secret(passwordEncoder.encode("123456"))
                //授权方式，在给febs做授权的时候可以用哪种授权方式授权
                .authorizedGrantTypes("password", "refresh_token")
                .scopes("all");//febs有哪些权限
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
        endpoints.tokenStore(tokenStore())// token存储
                .userDetailsService(userDetailService)
                // 传给他一个authenticationManager用来校验传过来的用户信息是不是合法的
                .authenticationManager(authenticationManager)
                .tokenServices(defaultTokenServices());
    }

    @Bean
    public TokenStore tokenStore() {
        return new RedisTokenStore(redisConnectionFactory);
    }

    @Primary
    @Bean
    public DefaultTokenServices defaultTokenServices() {
        DefaultTokenServices tokenServices = new DefaultTokenServices();
        tokenServices.setTokenStore(tokenStore());
        tokenServices.setSupportRefreshToken(true);
        tokenServices.setAccessTokenValiditySeconds(60 * 60 * 24);
        tokenServices.setRefreshTokenValiditySeconds(60 * 60 * 24 * 7);
        return tokenServices;
    }
}

```
- `BeanAuthenticationManager`和`PasswordEncoder`来自于FebsSecurityConfigure配置类中注册的
- 在`FebsAuthorizationServerConfigure`中，tokenStore使用的是**RedisTokenStore**，认证服务器生成的令牌将被存储到Redis中。
- `defaultTokenServices`指定了令牌的基本配置，比如令牌有效时间为60 * 60 * 24秒，刷新令牌有效时间为60 * 60 * 24 * 7秒，`setSupportRefreshToken`设置为true表示开启刷新令牌的支持。
- `configure(ClientDetailsServiceConfigurer clients)`方法。该方法主要配置了：
    1. 客户端从认证服务器获取令牌的时候，必须使用client_id为febs，client_secret为123456的标识来获取；
    2. 该client_id支持password模式获取令牌，并且可以通过refresh_token来获取新的令牌；
    3. 在获取client_id为febs的令牌的时候，scope只能指定为all，否则将获取失败；

> 如果需要指定多个client，可以继续使用`withClient`配置。

最后定义一个Controller：

```java
@RestController
public class SecurityController {
    @Autowired
    private ConsumerTokenServices consumerTokenServices;
    @Autowired
    private ValidateCodeService validateCodeService;

    @GetMapping("oauth/test")
    public String testOauth(){
        return "oauth";
    }
    @GetMapping("user")
    public Principal currentUser(Principal principal) {
        return principal;
    }

    @DeleteMapping("signout")
    public FebsResponse signout(HttpServletRequest request) throws FebsAuthException {
        String authorization = request.getHeader("Authorization");
        String token = StringUtils.replace(authorization, "bearer ", "");
        FebsResponse febsResponse = new FebsResponse();
        if (!consumerTokenServices.revokeToken(token)) {
            throw new FebsAuthException("退出登录失败");
        }
        return febsResponse.message("退出登录成功");
    }

    @GetMapping("captcha")
    public void captcha(HttpServletRequest request, HttpServletResponse response) throws IOException, ValidateCodeException {
        validateCodeService.create(request, response);
    }
}
```

`FebsResponse`为系统的统一相应格式，我们在febs-common模块中定义它:

```java
package com.sunsas.febs.common.entity;

public class FebsResponse extends HashMap<String, Object> {
    private static final long serialVersionUID = -8713837118340960775L;

    public FebsResponse message(String message) {
        this.put("message", message);
        return this;
    }

    public FebsResponse data(Object data) {
        this.put("data", data);
        return this;
    }

    @Override
    public FebsResponse put(String key, Object value) {
        super.put(key, value);
        return this;
    }

    public String getMessage() {
        return String.valueOf(get("message"));
    }

    public Object getData() {
        return get("data");
    }
}
```

`FebsAuthException`为自定义异常，在febs-common模块新增exception包:

```java
package com.sunsas.febs.common.exception;

public class FebsAuthException extends Exception{

    private static final long serialVersionUID = -6916154462432027437L;

    public FebsAuthException(String message){
        super(message);
    }
}
```

测试略

### 2.5 Gateway 微服务网关
在微服务的架构中，服务网关就是一个**介于客户端与服务端之间的中间层**。在这种情况下，**客户端只需要跟服务网关交互**，无需调用具体的微服务接口。这样的好处在于，客户端可以降低复杂性，无需关注具体是哪个微服务在提供服务。这一节我们将使用Spring Cloud **Zuul**搭建微服务网关febs-gateway。

同auth模块，新建module，Spring Initializr项目，名称由febs-auth改为febs-gateway

pom.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.sunsas</groupId>
        <artifactId>febs-cloud</artifactId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../febs-cloud/pom.xml</relativePath>
    </parent>
    <groupId>com.sunsas</groupId>
    <artifactId>febs-gateway</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>FEBS-Gateway</name>
    <description>FEBS-Gateway微服务网关</description>


    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
        </dependency>

        <dependency>
            <groupId>com.sunsas</groupId>
            <artifactId>febs-common</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <!--<dependency>-->
        <!--    <groupId>com.alibaba.csp</groupId>-->
        <!--    <artifactId>sentinel-zuul-adapter</artifactId>-->
        <!--    <version>1.6.3</version>-->
        <!--</dependency>-->
        <!--<dependency>-->
        <!--    <groupId>net.logstash.logback</groupId>-->
        <!--    <artifactId>logstash-logback-encoder</artifactId>-->
        <!--    <version>6.1</version>-->
        <!--</dependency>-->
    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>


</project>

```
注释掉的和现在没关系。

启动类添加:

```java
@EnableZuulProxy
@EnableDiscoveryClient
```

application.yml:

```yml
server:
  port: 8301

spring:
  application:
    name: FEBS-Gateway
  autoconfigure:
    exclude: org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration
  boot:
    admin:
      client:
        url: http://${febs-monitor-admin}:8401
        username: febs
        password: 123456

info:
  app:
    name: ${spring.application.name}
    description: "@project.description@"
    version: "@project.version@"

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: ALWAYS

eureka:
  instance:
    lease-renewal-interval-in-seconds: 20
  client:
    register-with-eureka: true
    fetch-registry: true
    instance-info-replication-interval-seconds: 30
    registry-fetch-interval-seconds: 3
    serviceUrl:
      defaultZone: http://febs:123456@${febs-register}:8001/register/eureka/

zuul:
  routes:
    auth:
      # /auth开头的请求都会被转发到名称为FEBS-Auth的服务上
      path: /auth/**
      serviceId: FEBS-Auth
      # sensitiveHeaders设置为*，表示不过滤请求头信息，即请求的请求头信息将原封不动的转发出去
      sensitiveHeaders: "*"
    system:
      path: /system/**
      serviceId: FEBS-Server-System
      sensitiveHeaders: "*"
    test:
      path: /test/**
      serviceId: FEBS-Server-Test
      sensitiveHeaders: "*"
  # zuul.retryable，设置为true时，表示开启重试机制；
  # zuul.ignored-services，Zuul配合Eureka后会有一套默认的配置规则，这里我们只想请求根据我们显示配置的路由规则走，所以设置为*，表示关闭所有默认路由配置规则；
  # zuul.ribbon.eager-load.enabled，Zuul内部通过Ribbon按照一定的负载均衡算法来获取服务，Ribbon进行客户端负载均衡的Client并不是在服务启动的时候就初始化好的，
  # 而是在调用的时候才会去创建相应的Client，所以第一次调用的耗时不仅仅包含发送HTTP请求的时间，还包含了创建RibbonClient的时间，这样一来如果创建时间速度较慢，
  # 同时设置的超时时间又比较短的话，第一次请求很容易出现超时的情况。设置为true的时候表示开启Ribbon的饥饿加载模式，即在应用启动的时候就去获取相应的Client备用。
  retryable: true
  ignored-services: "*"
  ribbon:
    eager-load:
      enabled: true
  host:
    connect-timeout-millis: 5000
    socket-timeout-millis: 5000
  SendErrorFilter:
    error:
      disable: true


hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 60000

ribbon:
  ReadTimeout: 60000
  ConnectTimeout: 60000
```

我们只关注zuul的配置，详细也在注释中写了。

写一个web安全配置类。在febs-gateway模块新增configure包，然后在该包下新增`FebsGatewaySecurityConfigure`配置类:

```java
package com.sunsas.febs.gateway.configure;

/**
 * 功能描述: 因为febs-gateway引入了febs-common模块，febs-common模块包含了Spring Cloud Security依赖，
 * 所以我们需要定义一个自己的WebSecurity配置类，来覆盖默认的。这里主要是关闭了csrf功能，否则会报csrf相关异常。
 * @Date: 2019/11/22 18:20
 */
@EnableWebSecurity
public class FebsGatewaySecurityConfigure extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();
    }
}
```

### 2.6 资源服务器
本节的目标是搭建**两个微服务提供者**（同时也是资源服务器）febs-server-system和febs-server-test，主要目的是为了演示**认证服务器和资源服务器在分离的模式**下，如何进行资源保护和资源获取。

#### 2.6.1 创建父项目febs-server
因为存在多个微服务提供者，所以我们先新增一个**febs-server作为这些微服务的父项目**，统一进行管理。

File -> New -> Module...新增一个Maven模块  
当然它的父项目还是febs-cloud，模块名**febs-server**。路径还是和其余项目平级:D:\febs\febs-server

pom.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>febs-cloud</artifactId>
        <groupId>com.sunsas</groupId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../febs-cloud/pom.xml</relativePath>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <modules>
        <module>febs-server-system</module>
        <module>febs-server-test</module>
    </modules>

    <artifactId>febs-server</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>FEBS-Server</name>
    <description>FEBS-Server微服务提供模块</description>

    <dependencies>
        <dependency>
            <groupId>com.sunsas</groupId>
            <artifactId>febs-common</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>dynamic-datasource-spring-boot-starter</artifactId>
            <version>2.5.4</version>
        </dependency>
        <!-- 其中p6sy用于在控制台中打印MyBatis执行的SQL，便于异常分析。 -->
        <dependency>
            <groupId>p6spy</groupId>
            <artifactId>p6spy</artifactId>
            <version>3.8.1</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-sleuth</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zipkin</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.amqp</groupId>
            <artifactId>spring-rabbit</artifactId>
        </dependency>
    </dependencies>
</project>
```
一开始只需引入common模块即可，可以看到它有两个子module，接下我们创建它们。

#### 2.6.2 febs-server-system
File -> New -> Modules...，选择Spring Initialzr
模块名：febs-server-system，文件路径D:\febs\febs-server\febs-server-system

pom.xml:

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.sunsas</groupId>
        <artifactId>febs-server</artifactId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <groupId>com.sunsas</groupId>
    <artifactId>febs-server-system</artifactId>
    <version>1.0-SNAPSHOT</version>
    <name>Febs-Server-System</name>
    <description>Febs-Server-System微服务系统模块</description>

    <dependencies>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.9.2</version>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.9.2</version>
        </dependency>
        <dependency>
            <groupId>net.logstash.logback</groupId>
            <artifactId>logstash-logback-encoder</artifactId>
            <version>6.1</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```
所需要的依赖基本在父项目febs-server引入了，这里就设置它的parent即可，其余的swagger，日志打印不重要。

启动类加上注解
```java
// 注册到eureka中去
@EnableDiscoveryClient
// 表示开启Spring Cloud Security权限注解
@EnableGlobalMethodSecurity(prePostEnabled = true)
```

application.yml

```yml
server:
  port: 8201

spring:
  application:
    name: FEBS-Server-System
  datasource:
    dynamic:
      hikari:
        connection-timeout: 30000
        max-lifetime: 1800000
        max-pool-size: 15
        min-idle: 5
        connection-test-query: select 1
        pool-name: FebsHikariCP
      primary: base
      datasource:
        base:
          username: root
          password: 123456
          driver-class-name: com.mysql.cj.jdbc.Driver
          url: jdbc:mysql://${mysql.url}:3306/febs_cloud_base?useUnicode=true&characterEncoding=UTF-8&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=GMT%2b8
      # p6spy适合在开发环境用于问题分析，其会带来一定的性能耗损，所以在生产环境这个配置最好改为false，将其关闭
      p6spy: true
  boot:
    admin:
      client:
        url: http://${febs-monitor-admin}:8401
        username: febs
        password: 123456
  zipkin:
    sender:
      type: rabbit
  sleuth:
    sampler:
      probability: 1
  rabbitmq:
    host: ${rabbitmq.url}
    port: 5672
    username: febs
    password: 123456
  autoconfigure:
    exclude: org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration


info:
  app:
    name: ${spring.application.name}
    description: "@project.description@"
    version: "@project.version@"

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: ALWAYS

eureka:
  instance:
    lease-renewal-interval-in-seconds: 20
  client:
    register-with-eureka: true
    fetch-registry: true
    instance-info-replication-interval-seconds: 30
    serviceUrl:
      defaultZone: http://febs:123456@${febs-register}:8001/register/eureka/

# user-info-uri路径为http://localhost:8301/auth/user，通过微服务网关，
# 该请求将被转发到http://localhost:8101/user。该配置的作用主要有两个：
# 1.到认证服务器里校验当前请求头中的令牌是否为合法的令牌
# 2.通过当前令牌获取对应的用户信息
security:
  oauth2:
    resource:
      id: ${spring.application.name}
      user-info-uri: http://${febs-gateway}:8301/auth/user


mybatis-plus:
  type-aliases-package: com.sunsas.febs.common.entity.system
  mapper-locations: classpath:mapper/*/*.xml
  configuration:
    jdbc-type-for-null: null
  global-config:
    banner: false

```

创建一个**资源服务器配置类**。在server-system下新增configure包:

```
package com.sunsas.febs.server.system.configure;

/**
 * 功能描述: <br>所有访问febs-server-system的请求都需要认证，只有通过认证服务器发放的令牌才能进行访问。
 * @author Lenovo
 * @Date: 2019/11/26 11:19
 */
@Configuration
@EnableResourceServer
public class FebsServerSystemResourceServerConfigure extends ResourceServerConfigurerAdapter {
    // 这两个类同之前的auth，拒绝策略在common包下。
    @Autowired
    private FebsAccessDeniedHandler febsAccessDeniedHandler;
    @Autowired
    private FebsAuthExceptionEntryPoint febsAuthExceptionEntryPoint;
    // 配置属性类
    @Resource
    private FebsServerSystemProperties febsServerSystemProperties;


    @Override
    public void configure(HttpSecurity http) throws Exception {
        String[] anonUrls = StringUtils.splitByWholeSeparatorPreserveAllTokens(febsServerSystemProperties.getAnonUrl(), ",");

        http.csrf().disable()
                .requestMatchers().antMatchers("/**")
                .and()
                .authorizeRequests().antMatchers("/actuator/**").permitAll()
                .and()
                .authorizeRequests()
                .antMatchers(anonUrls).permitAll()
                .antMatchers("/**").authenticated();
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) {
        resources.authenticationEntryPoint(febsAuthExceptionEntryPoint)
                .accessDeniedHandler(febsAccessDeniedHandler);
    }
}

```
配置属性和之前类似，读取一个类，这个类关联一个properties文件。


```java
package com.sunsas.febs.server.system.properties;

@Data
@SpringBootConfiguration
@PropertySource(value = {"classpath:febs-server-system.properties"})
@ConfigurationProperties(prefix = "febs.server.system")
public class FebsServerSystemProperties {
    /**
     * 免认证 URI，多个值的话以逗号分隔
     */
    private String anonUrl;

    private FebsSwaggerProperties swagger = new FebsSwaggerProperties();
}
```
`febs-server-system.properties`
```
febs.server.system.swagger.basePackage=cc.mrbird.febs.server.system.controller
febs.server.system.swagger.title=FEBS-Server-System API
febs.server.system.swagger.description=FEBS-Server-System API.
febs.server.system.swagger.version=1.0
febs.server.system.swagger.author=MrBird
febs.server.system.swagger.url=https://mrbird.cc
febs.server.system.swagger.email=852252810@qq.com
febs.server.system.swagger.license=Apache 2.0
febs.server.system.swagger.licenseUrl=https://www.apache.org/licenses/LICENSE-2.0.html

febs.server.system.anonUrl=/swagger-ui.html,/webjars/**,/swagger-resources/**,/v2/api-docs/**,/,/csrf,/actuator/**

febs.server.system.swagger.grantUrl=http://${febs-gateway}:8301/auth/oauth/token
febs.server.system.swagger.name=febs_oauth_swagger
febs.server.system.swagger.scope=test
```
除了白名单的请求都需要认证，只有通过认证服务器发放的令牌才能进行访问。

新建controller类，提供REST服务

```
package com.sunsas.febs.server.system.controller;

@Slf4j
@RestController
public class TestController {

    @GetMapping("info")
    public String test(){
        return "febs-server-system";
    }

    @GetMapping("currentUser")
    public Principal currentUser(Principal principal){
        return principal;
    }

    @GetMapping("hello")
    public String hello(String name) {
        log.info("/hello服务被调用");
        return "hello" + name;
    }
}

```

和其它模块一样，建一个banner.txt，内容和之前一样。

#### 2.6.3 febs-server-test

同febs-server-system（以下简称system）

pom.xml与system类似，只是没有依赖**swagger**了，代码不贴了，注意名称不同即可。

启动同类注解同system

application.yml同样类似：

```yml
server:
  port: 8202

spring:
  application:
    name: FEBS-Server-Test
  autoconfigure:
    exclude: org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,com.baomidou.dynamic.datasource.spring.boot.autoconfigure.DynamicDataSourceAutoConfiguration,org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration
  boot:
    admin:
      client:
        url: http://${febs-monitor-admin}:8401
        username: febs
        password: 123456
  zipkin:
    sender:
      type: rabbit
  sleuth:
    sampler:
      probability: 1
  rabbitmq:
    host: ${rabbitmq.url}
    port: 5672
    username: febs
    password: 123456

info:
  app:
    name: ${spring.application.name}
    description: "@project.description@"
    version: "@project.version@"

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: ALWAYS


eureka:
  instance:
    lease-renewal-interval-in-seconds: 20
  client:
    register-with-eureka: true
    fetch-registry: true
    instance-info-replication-interval-seconds: 30
    registry-fetch-interval-seconds: 3
    serviceUrl:
      defaultZone: http://febs:123456@${febs-register}:8001/register/eureka/

security:
  oauth2:
    resource:
      id: ${spring.application.name}
      user-info-uri: http://${febs-gateway}:8301/auth/user

feign:
  hystrix:
    enabled: true
    shareSecurityContext: true
#把SecurityContext对象从你当前主线程传输到Hystrix线程
hystrix:
  shareSecurityContext: true

```
端口号为8202，服务名称为FEBS-Server-Test。

同样建立**资源服务器配置类**：

```java
package com.sunsas.febs.server.test.configure;

import com.sunsas.febs.common.handler.FebsAccessDeniedHandler;
import com.sunsas.febs.common.handler.FebsAuthExceptionEntryPoint;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;

@Configuration
@EnableResourceServer
public class FebsServerTestResourceServerConfigure extends ResourceServerConfigurerAdapter {
    @Autowired
    private FebsAccessDeniedHandler accessDeniedHandler;
    @Autowired
    private FebsAuthExceptionEntryPoint exceptionEntryPoint;

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
                .requestMatchers().antMatchers("/**")
                .and()
                .authorizeRequests().antMatchers("/actuator/**").permitAll()
                .and()
                .authorizeRequests()
                .antMatchers("/**").authenticated();
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) {
        resources.authenticationEntryPoint(exceptionEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);
    }
}

```
与system不同的是，没有额外去写属性配置类，而是直接写死。
`.authorizeRequests().antMatchers("/actuator/**").permitAll()`

建立controller

```
package com.sunsas.febs.server.test.controller;

@Slf4j
@EnableFebsOauth2FeignClient
@RestController
public class TestController {
    @Autowired
    private IHelloService helloService;

    @GetMapping("test1")
    @PreAuthorize("hasAnyAuthority('user:add')")
    public String test1(){
        return "拥有'user:add'权限";
    }

    @GetMapping("test2")
    @PreAuthorize("hasAnyAuthority('user:update')")
    public String test2(){
        return "拥有'user:update'权限";
    }

    @GetMapping("user")
    public Principal currentUser(Principal principal) {
        return principal;
    }

    @GetMapping("hello")
    public String hello(String name){
        log.info("Feign调用febs-server-system的/hello服务");
        return this.helloService.hello(name);
    }
}

```
`@PreAuthorize("hasAnyAuthority('user:add')")`表示此方法受权限保护，只有拥有`user:add`才能访问。而我们之前的伪造的用户只拥有`user:add`,没有`user:update`,所以测试时，携带了token也会说无权限访问。

和其他项目一样可以新建 banner.txt，

这两个项目完成了，我们需要去**网关中添加路由配置**
（虽然我一开始就写上去了）
```
zuul:
  routes:
    auth:
      # /auth开头的请求都会被转发到名称为FEBS-Auth的服务上
      path: /auth/**
      serviceId: FEBS-Auth
      # sensitiveHeaders设置为*，表示不过滤请求头信息，即请求的请求头信息将原封不动的转发出去
      sensitiveHeaders: "*"
    system:
      path: /system/**
      serviceId: FEBS-Server-System
      sensitiveHeaders: "*"
    test:
      path: /test/**
      serviceId: FEBS-Server-Test
      sensitiveHeaders: "*"
```


**至此基础框架搭建完毕，然后我们将进入架构完善**


> 参考
>
> [Spring Cloud微服务安全实战_4-4_OAuth2协议与微服务安全](https://www.cnblogs.com/lihaoyang/p/12045480.html)



---


## 5.2.3. 架构完善

### 3.1 参数配置化
所谓参数配置话，其实之前有一部分已经是了，就是资源服务器配置类中，我们可以读取配置文件的参数。

现在我们来修改febs-auth中的认证服务器配置类`FebsAuthorizationServerConfigure`,里面使用硬编码的形式配置了client_id，client_secret等信息。硬编码的形式不利于代码维护和升级，所以我们需要将它改造为可配置的方式。

自定义配置类还需引入`spring-boot-configuration-processor`依赖，因为这个依赖会在多个微服务子系统里使用到，所以将其添加到febs-common的pom文件中：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```
首先是一个和Auth相关的配置类`FebsAuthProperties`：

```java
package com.sunsas.febs.auth.properties;

import lombok.Data;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;

/**
 * 功能描述: <br>@PropertySource(value = {"classpath:febs-auth.properties"})用于指定读取的配置文件路径；
 * @ConfigurationProperties(prefix = "febs.auth")指定了要读取的属性的统一前缀名称为febs.auth；
 * @SpringBootConfiguration实质上为@Component的派生注解，用于将FebsAuthProperties纳入到IOC容器中。
 * @Author: Lenovo
 * @Date: 2019/11/26 13:42
 */
@Data
@SpringBootConfiguration
@PropertySource(value = {"classpath:febs-auth.properties"})
@ConfigurationProperties(prefix = "febs.auth")
public class FebsAuthProperities {

    private FebsClientProperties[] clients = {};
    private int accessTokenValiditySeconds = 60 * 60 * 24;
    private int refreshTokenValiditySeconds = 60 * 60 * 24 * 7;
    // 免认证路径
    private String anonUrl;
    // 验证码配置类,后面再说
    // private FebsValidateCodeProperties code = new FebsValidateCodeProperties();
}
```

Client配置类:`FebsClientsProperties`

```java
@Data
public class FebsClientProperties {
    private String client;
    private String secret;
    private String grantType = "password,authorization_code,refresh_token";
    private String scope = "all";
}
```

`private FebsClientProperties[] clients = {};`**一个认证服务器可以根据多种Client来发放对应的令牌，所以这个属性使用的是数组形式**；

接下来在febs-auth的resources路径下新建**配置文件**`febs-auth.properties`
```
febs.auth.accessTokenValiditySeconds=86400
febs.auth.refreshTokenValiditySeconds=604800

febs.auth.clients[0].client=febs
febs.auth.clients[0].secret=123456
febs.auth.clients[0].grantType=password,authorization_code,refresh_token
febs.auth.clients[0].scope=all

febs.auth.clients[1].client=swagger
febs.auth.clients[1].secret=123456
febs.auth.clients[1].grantType=password
febs.auth.clients[1].scope=test

febs.auth.code.time=120
febs.auth.code.type=png
febs.auth.code.width=115
febs.auth.code.height=42
febs.auth.code.length=4
febs.auth.code.charType=2

febs.auth.anonUrl=/captcha,/actuator/**
```

这些属性会被读取，然后去改造**认证服务器配置类**`FebsAuthorizationServerConfigure`
我们之前是写死的，现在改为读取配置：

```java
package com.sunsas.febs.auth.configure;

@Configuration
@EnableAuthorizationServer
public class FebsAuthorizationServerConfigurer extends AuthorizationServerConfigurerAdapter {
    // AuthenticationManager来自于FebsSecurityConfigure配置类
    @Autowired
    private AuthenticationManager authenticationManager;
    @Autowired
    private RedisConnectionFactory redisConnectionFactory;
    @Autowired
    private FebsUserDetailService userDetailService;
    // PasswordEncoder来自于FebsSecurityConfigure配置类
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private FebsAuthProperities febsAuthProperities;
    // 异常翻译器，将这些认证类型异常翻译为友好的格式，下节说明
    @Autowired
    private FebsWebResponseExceptionTranslator febsWebResponseExceptionTranslator;

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        FebsClientProperties[] clientArray = febsAuthProperities.getClients();
        InMemoryClientDetailsServiceBuilder builder = clients.inMemory();
        // 由原先硬编码的形式改造成了从配置文件读取配置的形式，并且判断了client和secret不能为空；
        if(ArrayUtils.isNotEmpty(clientArray)){
            for(FebsClientProperties client : clientArray){
                if(StringUtils.isBlank(client.getClient())){
                    throw new Exception("client不能为空");
                }
                if(StringUtils.isBlank(client.getSecret())){
                    throw new Exception("secret不能为空");
                }
                String[] grantTypes = StringUtils.splitByWholeSeparatorPreserveAllTokens(client.getGrantType(), ",");
                builder.withClient(client.getClient())
                        .secret(passwordEncoder.encode(client.getSecret()))
                        .authorizedGrantTypes(grantTypes)
                        .scopes(client.getScope());
            }
        }
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
        endpoints.tokenStore(tokenStore())
                .userDetailsService(userDetailService)
                .authenticationManager(authenticationManager)
                .tokenServices(defaultTokenServices())
                .exceptionTranslator(febsWebResponseExceptionTranslator);
    }
    @Bean
    public TokenStore tokenStore() {
        return new RedisTokenStore(redisConnectionFactory);
    }

    @Primary
    @Bean
    public DefaultTokenServices defaultTokenServices() {
        DefaultTokenServices tokenServices = new DefaultTokenServices();
        tokenServices.setTokenStore(tokenStore());
        tokenServices.setSupportRefreshToken(true);
        // 指定有效时间也从原先硬编码的形式改造成了从配置文件读取配置的形式。
        tokenServices.setAccessTokenValiditySeconds(febsAuthProperities.getAccessTokenValiditySeconds());
        tokenServices.setRefreshTokenValiditySeconds(febsAuthProperities.getRefreshTokenValiditySeconds());
        return tokenServices;
    }
}
```

### 3.2 异常处理

#### 3.2.1 认证异常处理
上节说到的异常翻译器`FebsWebResponseExceptionTranslator`

默认情况下，当我们在获取令牌时输入错误的用户名或密码，或者当grant_type错误时，系统返回会比较菜，可读性差。

```java
package com.sunsas.febs.auth.translator;


import com.sunsas.febs.common.entity.FebsResponse;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.oauth2.common.exceptions.InvalidGrantException;
import org.springframework.security.oauth2.common.exceptions.UnsupportedGrantTypeException;
import org.springframework.security.oauth2.provider.error.WebResponseExceptionTranslator;
import org.springframework.stereotype.Component;

/**
 * 功能描述: <br>@sl4j注解为lombok类型注解，用于往当前类中注入org.slf4j.Logger日志打印对象，效果相当于在类里定义如下属性：
 * private Logger log = LoggerFactory.getLogger(this.getClass());

 * @Author: Lenovo
 * @Date: 2019/11/26 15:41
 */
@Slf4j
@Component
public class FebsWebResponseExceptionTranslator implements WebResponseExceptionTranslator {

    @Override
    public ResponseEntity translate(Exception e){
        ResponseEntity.BodyBuilder status = ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR);
        FebsResponse response = new FebsResponse();
        String message = "认证失败";
        log.error(message, e);
        if (e instanceof UnsupportedGrantTypeException) {
            message = "不支持该认证类型";
            return status.body(response.message(message));
        }
        if (e instanceof InvalidGrantException) {
            if (StringUtils.containsIgnoreCase(e.getMessage(), "Invalid refresh token")) {
                message = "refresh token无效";
                return status.body(response.message(message));
            }
            if (StringUtils.containsIgnoreCase(e.getMessage(), "locked")) {
                message = "用户已被锁定，请联系管理员";
                return status.body(response.message(message));
            }
            message = "用户名或密码错误";
            return status.body(response.message(message));
        }
        return status.body(response.message(message));
    }
}

```

#### 3.2.2 处理资源服务器异常
资源服务器异常主要有两种：**令牌不正确**返回401和**用户无权限**返回403。因为资源服务器有多个，所以相关的异常处理类可以定义在febs-common通用模块里。

之前多次看到的`FebsAccessDeniedHandler,FebsAuthExceptionEntryPoint`就是两个异常处理类了。
在febs-common模块cc.mrbird.febs.common路径下新建handler包


```java
package com.sunsas.febs.common.handler;

/**
 * 功能描述: <br>FebsAuthExceptionEntryPoint实现了AuthenticationEntryPoint接口的commence方法，在方法内自定义了响应的格式。
 * 其中application/json;charset=UTF-8和HTTP状态码401
 * @Author: Lenovo
 * @Date: 2019/11/26 16:08
 */
public class FebsAuthExceptionEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException {
        FebsResponse febsResponse = new FebsResponse();

        FebsUtil.makeResponse(httpServletResponse,MediaType.APPLICATION_JSON_UTF8_VALUE,
                HttpServletResponse.SC_UNAUTHORIZED,febsResponse.message("token无效"));
    }
}

```

```java
package com.sunsas.febs.common.handler;

/**
 * 功能描述: <br>FebsAuthExceptionEntryPoint实现了AuthenticationEntryPoint接口的commence方法，在方法内自定义了响应的格式。
 * 响应码为HttpServletResponse.SC_FORBIDDEN，即403。
 * @Author: Lenovo
 * @Date: 2019/11/26 16:08
 */
public class FebsAccessDeniedHandler implements AccessDeniedHandler {


    @Override
    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException {
        FebsResponse febsResponse = new FebsResponse();

        FebsUtil.makeResponse(
                httpServletResponse, MediaType.APPLICATION_JSON_UTF8_VALUE,
                HttpServletResponse.SC_FORBIDDEN, febsResponse.message("没有权限访问该资源"));
    }
}

```

`FebsResponse`为系统的统一相应格式，之前说过了  
`FebsUtil`就是一个工具类，没什么好说的：

```java
package com.sunsas.febs.common.utils;

@Slf4j
public class FebsUtil {
    /**
     * 设置响应
     *
     * @param response    HttpServletResponse
     * @param contentType content-type
     * @param status      http状态码
     * @param value       响应内容
     * @throws IOException IOException
     */
    public static void makeResponse(HttpServletResponse response, String contentType,
                                    int status, Object value) throws IOException {
        response.setContentType(contentType);
        response.setStatus(status);
        response.getOutputStream().write(JSONObject.toJSONString(value).getBytes());
    }

    /**
     * 封装前端分页表格所需数据
     *
     * @param pageInfo pageInfo
     * @return Map<String, Object>
     */
    public static Map<String, Object> getDataTable(IPage<?> pageInfo) {
        Map<String, Object> data = new HashMap<>();
        data.put("rows", pageInfo.getRecords());
        data.put("total", pageInfo.getTotal());
        return data;
    }

    /**
     * 正则校验
     *
     * @param regex 正则表达式字符串
     * @param value 要匹配的字符串
     * @return 正则校验结果
     */
    public static boolean match(String regex, String value) {
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(value);
        return matcher.matches();
    }
}

```

由于febs-common模块是一个普通的maven项目，并不是一个Spring Boot项目，所以即使使用@Component注解标注，**也不能被成功注册到各个微服务子系统的Spring IOC容器中**，我们可以通过**自定义Enable注解**来解决

在febs-common模块下新建annotation包，然后在该包下新`建EnableFebsAuthExceptionHandler`注解

```java
package com.sunsas.febs.common.annotation;

/**
 * 功能描述: <br>我们使用@Import将FebsAuthExceptionConfigure配置类引入了进来。
 * 直接在入口类上使用即可
 * @Author: Lenovo
 * @Date: 2019/11/26 17:15
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(FebsAuthExceptionConfigure.class)
public @interface EnableFebsAuthExceptionHandler {
}
```
> 这种enable注解在后续项目中经常用到


```java
package com.sunsas.febs.common.configure;

/**
 * 功能描述: <br>因为febs-common模块是一个普通的maven项目，并不是一个Spring Boot项目，所以即使在这两个类(异常处理类）上使用@Component注解标注，
 * 它们也不能被成功注册到各个微服务子系统的Spring IOC容器中。我们可以使用@Enable模块驱动的方式来解决这个问题。
 * @ConditionalOnMissingBean注解的意思是，当IOC容器中没有指定名称或类型的Bean的时候，就注册它。
 * 以@ConditionalOnMissingBean(name = "accessDeniedHandler")为例，当微服务系统的Spring IOC容器中没有名称为accessDeniedHandler的Bean的时候，
 * 就将FebsAccessDeniedHandler注册为一个Bean。这样做的好处在于，子系统可以自定义自个儿的资源服务器异常处理器，覆盖我们在febs-common通用模块里定义的。
 * @Author: Lenovo
 * @Date: 2019/11/26 17:03
 */
public class FebsAuthExceptionConfigure {

    @Bean
    @ConditionalOnMissingBean(name = "accessDeniedHandler")
    public FebsAccessDeniedHandler accessDeniedHandler() {
        return new FebsAccessDeniedHandler();
    }

    @Bean
    @ConditionalOnMissingBean(name = "authenticationEntryPoint")
    public FebsAuthExceptionEntryPoint authenticationEntryPoint() {
        return new FebsAuthExceptionEntryPoint();
    }
}
```

这个注解使用就很简单了，只要在启动类上加`@EnableFebsAuthExceptionHandler`，那么该服务就把`FebsAccessDeniedHandler,FebsAuthExceptionEntryPoint`注册到它的Spring容器中，就可以自动装配了。
```java
@Autowired
private FebsAccessDeniedHandler accessDeniedHandler;
@Autowired
private FebsAuthExceptionEntryPoint exceptionEntryPoint;
```

#### 3.2.3 处理Zuul异常

自定义Zuul异常处理可以通过继承Zuul的SendErrorFilter过滤器来实现,主要解决**转发请求超时**，**处理转发请求的微服务模块不可用**异常。

在**febs-gateway**模块新建filter包，新建`FebsGatewayErrorFilter`过滤器

```java
package com.sunsas.febs.gateway.filter;

@Slf4j
@Component
public class FebsGatewayErrorFilter extends SendErrorFilter {

    @Override
    public Object run() {
        try{
            FebsResponse febsResponse = new FebsResponse();
            // RequestContext获取到当前请求上下文，通过请求上下文可以获取到当前请求的服务名称serviceId和当前请求的异常对象ExceptionHolder等信息。
            // 通过异常对象我们可以继续获取到异常内容，根据不同的异常内容我们可以自定义想要的响应。
            RequestContext requestContext = RequestContext.getCurrentContext();
            String serviceId = (String) requestContext.get(FilterConstants.SERVICE_ID_KEY);

            ExceptionHolder exceptionHolder = findZuulException(requestContext.getThrowable());
            String errorCause = exceptionHolder.getErrorCause();
            Throwable throwable = exceptionHolder.getThrowable();
            String message = throwable.getMessage();
            System.out.println(throwable);
            message = StringUtils.isBlank(message) ? errorCause : message;
            febsResponse = resolveExceptionMessage(message, serviceId, febsResponse);

            HttpServletResponse response = requestContext.getResponse();
            FebsUtil.makeResponse(response, MediaType.APPLICATION_JSON_UTF8_VALUE,
                    HttpServletResponse.SC_INTERNAL_SERVER_ERROR,febsResponse);
            log.error("Zull sendError：{}", febsResponse.getMessage());
        } catch (Exception e) {
            log.error("Zuul sendError", e);
            ReflectionUtils.rethrowRuntimeException(e);
        }
        return null;
    }

    private FebsResponse resolveExceptionMessage(String message, String serviceId, FebsResponse febsResponse) {
        if (StringUtils.containsIgnoreCase(message, "time out")) {
            return febsResponse.message("请求" + serviceId + "服务超时");
        }
        if (StringUtils.containsIgnoreCase(message, "forwarding error")) {
            return febsResponse.message(serviceId + "服务不可用");
        }
        return febsResponse.message("Zuul请求" + serviceId + "服务异常");
    }
}
```

要让我们自定义的Zuul异常过滤器生效，还需要在febs-gateway的配置文件中添加如下配置，让默认的异常过滤器失效：

```yml
zuul:
  SendErrorFilter:
    error:
      disable: true
```

#### 3.2.4 全局异常处理
所谓的全局异常处理指的是**全局处理Controller层抛出来的异常**。因为全局异常处理器在各个微服务系统里都能用到，所以我们把它定义在febs-common模块里。

```java
package com.sunsas.febs.common.handler;

import com.sunsas.febs.common.entity.FebsResponse;
import com.sunsas.febs.common.exception.FebsAuthException;
import com.sunsas.febs.common.exception.FebsException;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.validation.BindException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;

import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;
import javax.validation.Path;
import java.util.List;
import java.util.Set;

/**
 * 功能描述: <br>全局异常处理指的是全局处理Controller层抛出来的异常
 */
@Slf4j
public class BaseExceptionHandler {
    @ExceptionHandler(value = Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public FebsResponse handleException(Exception e){
        log.error("系统内部异常，异常信息", e);
        return new FebsResponse().message("系统内部异常");
    }

    @ExceptionHandler(value = FebsAuthException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public FebsResponse handleFebsAuthException(FebsAuthException e) {
        log.error("系统错误", e);
        return new FebsResponse().message(e.getMessage());
    }

    @ExceptionHandler(value = AccessDeniedException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public FebsResponse handleAccessDeniedException(){
        return new FebsResponse().message("没有权限访问该资源");
    }

    @ExceptionHandler(value = FebsException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public FebsResponse handleFebsException(FebsException e) {
        log.error("系统错误", e);
        return new FebsResponse().message(e.getMessage());
    }

    /**
     * 功能描述: <br>当普通类型参数校验不合法时，控制器层会抛出javax.validation.ConstraintViolationException异常，
     * 在febs-common的BaseExceptionHandler里添加该类型异常捕获
     * @param e
     * @return: com.sunsas.febs.common.entity.FebsResponse
     * @Author: Lenovo
     * @Date: 2019/12/30 16:39
     */
    @ExceptionHandler(value = ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public FebsResponse handleConstraintViolationException(ConstraintViolationException e){
        StringBuilder message = new StringBuilder();
        Set<ConstraintViolation<?>> violations = e.getConstraintViolations();
        for(ConstraintViolation<?> violation : violations){
            Path path = violation.getPropertyPath();
            String[] pathArr = StringUtils.splitByWholeSeparatorPreserveAllTokens(path.toString(),".");
            message.append(pathArr[1]).append(violation.getMessage()).append(",");
        }
        message = new StringBuilder(message.substring(0, message.length()-1));
        return new FebsResponse().message(message.toString());
    }

    /**
     * 统一处理请求参数校验(实体对象传参)
     *
     * @param e BindException
     * @return FebsResponse
     */
    @ExceptionHandler(BindException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public FebsResponse handleBindException(BindException e) {
        StringBuilder message = new StringBuilder();
        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();
        for (FieldError error : fieldErrors) {
            message.append(error.getField()).append(error.getDefaultMessage()).append(",");
        }
        message = new StringBuilder(message.substring(0, message.length() - 1));
        return new FebsResponse().message(message.toString());
    }
}
```

还可以**在各自的微服务中新建异常处理类**（优先级要高于BaseExceptionHandler）：
```java
/**
 * 功能描述: <br>对于通用的异常类型捕获可以在BaseExceptionHandler中定义，
 * 而当前微服务系统独有的异常类型捕获可以在GlobalExceptionHandler中定义。
 * Order表示此类具有最高优先权（数字越小，优先级越高）
 * @Author: Lenovo
 * @Date: 2019/11/29 10:50
 */
@RestControllerAdvice
@Order(value = Ordered.HIGHEST_PRECEDENCE)
public class GlobalExceptionHandler extends BaseExceptionHandler {
    // ...
}
```

### 3.3 Feign
微服务之间服务的调用可以借助Spring Cloud Feign来完成，Spring Cloud Feign内部整合了Spring Cloud Ribbon和Spring Cloud Hystrix，所以它具有**客户端负载均衡和服务容错**的功能,

> Feign的原理: [Spring Cloud Feign设计原理](https://www.jianshu.com/p/8c7b92b4396c)，  大致就是通过基于面向接口的**动态代理方式生成实现类**，将请求调用委托到动态代理实现类。然后实行调用。

依赖放在common模块中：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

我们使用`febs-server-test`远程调用`febs-server-system`的方法。
需要在`febs-server-test`启动类加上注解`@EnableFeignClients`，表示开启Feign Client。

> 不用改动`febs-server-system`的代码

然后在`febs-server-test`模块新建service，定义一个Feign Client接口：

```java
package com.sunsas.febs.server.test.service;

/**
 * 功能描述: <br>value指定远程服务的名称，这个名称对应febs-server-system模块配置文件application.yml里spring.application.name的配置，即注册到Eureka里的服务名称；
 * contextId指定这个Feign Client的别名，当我们定义了多个Feign Client并且value值相同（即调用同一个服务）的时候，需要手动通过contextId设置别名，否则程序将抛出异常；
 * fallbackFactory指定了回退方法，当我们调用远程服务出现异常时，就会调用这个回退方法。fallback也可以指定回退方法，
 * 但fallbackFactory指定的回退方法里可以通过Throwable对象打印出异常日志，方便分析问题。
 * @Author: Lenovo
 * @Date: 2019/11/29 11:18
 */
@FeignClient(value = FebsServerConstant.FEBS_SERVER_SYSTEM, contextId = "helloServiceClient", fallbackFactory = HelloServiceFallback.class)
public interface IHelloService {

    @GetMapping("hello")
    String hello(@RequestParam("name") String name);
}
```
`FebsServerConstant`只是一个常量类：

```java
package com.sunsas.febs.common.entity;

/**
 * 功能描述: <br>微服务名称常量类
 * @Author: Lenovo
 * @Date: 2019/11/29 11:20
 */
public class FebsServerConstant {
    public static final String FEBS_AUTH = "FEBS-Auth";
    public static final String FEBS_CLOUD = "FEBS-Cloud";
    public static final String FEBS_COMMON = "FEBS-Common";
    public static final String FEBS_GATEWAY = "FEBS-Gateway";
    public static final String FEBS_REGISTER = "FEBS-Register";
    public static final String FEBS_SERVER = "FEBS-Server";
    public static final String FEBS_SERVER_SYSTEM= "FEBS-Server-System";
    public static final String FEBS_SERVER_TEST= "FEBS-Server-Test";
}
```

至于Hystrix的fallback之前说过了，这里使用了fallbackFactory：

```java
package com.sunsas.febs.server.test.service.fallback;

import com.sunsas.febs.server.test.service.IHelloService;
import feign.hystrix.FallbackFactory;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class HelloServiceFallback implements FallbackFactory<IHelloService> {

    @Override
    public IHelloService create(Throwable throwable) {
//        return new IHelloService() {
//            @Override
//            public String hello(String name) {
//                log.error("调用febs-server-system服务出错", throwable);
//                return "调用出错";
//            }
//        };
        // 因为IHelloService目前只包含一个抽象方法，所以它是一个函数式接口，上面的代码可用Lambda表达式简化为：
        return name -> {
            log.error("调用febs-server-system服务出错", throwable);
            return "调用出错";
        };

    }
}
```

**因为Feign的回退功能是基于Hystrix实现的**，所以需要开启它，需要在配置文件application.yml里添加如下配置：

```yml
feign:
  hystrix:
    enabled: true
```

调用也很简单，把刚才的接口注入进来，在febs-server-test的TestController中使用上面定义的IHelloService
```
@Autowired
private IHelloService helloService;
```

不过调用会失败，这是为何？因**为没有权限**。**Feign在调用远程服务的时候，并不会帮我们把原HTTP请求头部的内容也携带上**。

我们需要**拦截Feign请求，手动往请求头上加入令牌**
配置一个Feign请求拦截器，我们放在common模块下：

```java
package com.sunsas.febs.common.configure;

/**
 * 功能描述: <br>Feign在调用远程服务的时候，并不会帮我们把原HTTP请求头部的内容也携带上，
 * 所以访问febs-server-system的/hello服务的时候，请求头部没有访问令牌，于是抛出了401异常。
 * 我们通过SecurityContextHolder从请求上下文中获取了OAuth2AuthenticationDetails类型对象，
 * 并通过该对象获取到了请求令牌，然后在请求模板对象requestTemplate的头部手动将令牌添加上去。
 *
 *
 */
public class FebsOAuth2FeignConfigure {
    @Bean
    public RequestInterceptor oauth2FeignRequestInterceptor(){
        return requestTemplate -> {
            // 现在微服务需要校验Zuul Token，所以我们需要在上一节定义的Feign拦截器里也加入Zuul Token，否则Feign调用微服务会报403异常。
            String zuulToken = new String(Base64Utils.encode(FebsConstant.ZUUL_TOKEN_VALUE.getBytes()));
            requestTemplate.header(FebsConstant.ZUUL_TOKEN_HEADER, zuulToken);

            Object details = SecurityContextHolder.getContext().getAuthentication().getDetails();
            if (details instanceof OAuth2AuthenticationDetails) {
                String authorizationToken = ((OAuth2AuthenticationDetails) details).getTokenValue();
                requestTemplate.header(HttpHeaders.AUTHORIZATION, "bearer " + authorizationToken);
            }
        };
    }
}

```
zuul token下节说明。

> 由于各个服务之间调用都可能需要用到此拦截器，所以放在common模块。

要让**上面的请求拦截器能够顺利获取到令牌**，还需要在febs-server-test的配置文件里添加重要的配置：

```yml
# 配置把SecurityContext对象从你当前主线程传输到Hystrix线程。
hystrix:
  shareSecurityContext: true
```

和上面一样，我们需要自定义一个@Enable注解，能够使得`FebsOAuth2FeignConfigure`在其余微服务生效。

```java
package com.sunsas.febs.common.annotation;

import com.sunsas.febs.common.configure.FebsOAuth2FeignConfigure;
import org.springframework.context.annotation.Import;

import java.lang.annotation.*;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(FebsOAuth2FeignConfigure.class)
public @interface EnableFebsOauth2FeignClient {
}
```

然后在`febs-server-test`模块的入口类上使用`@EnableFebsOauth2FeignClient`注解`即可


### 3.4 微服务防护

上节说到的zuul token是为了做微服务防护。虽然我们加了网关，但是各个微服务的接口仍然暴露在外，可以不通过网关直接访问，那这肯定是不安全的。

解决思路是通过网关调用的，会在头部加上网关信息，在处理请求的微服务上定义全局拦截器，校验请求头部的网关信息。这样绕过网关的请求就会被拦截掉。

思路
1. 在网关中给所有请求加上一个请求密钥
2. 在服务添加过滤器，验证密钥

#### 3.4.1 生成Token

我们在febs-gateway模块下新建`FebsGatewayRequestFilter`拿到上下文，并且加上密钥

```java
package com.sunsas.febs.gateway.filter;

/**
 * 功能描述: <br>定义一个优先级在PreDecorationFilter (order为5） 之后的过滤器，这样便可以拿到请求上下文。
 * 〈〉在网关转发请求前，请求头部加入网关信息，然后在处理请求的微服务模块里定义全局拦截器，校验请求头部的网关信息，这样就能避免客户端直接访问微服务了。
 * @Param:
 * @Return: 
 * @Author: Lenovo
 * @Date: 2019/12/19 16:17
 */
@Slf4j
@Component
public class FebsGatewayRequestFilter extends ZuulFilter {
    @Autowired
    private FebsGatewayProperties properties;

    private AntPathMatcher pathMatcher = new AntPathMatcher();
    /**
     * 功能描述: <br>对应Zuul生命周期的四个阶段：pre、post、route和error，我们要在请求转发出去前添加请求头，所以这里指定为pre
     * @Date: 2019/12/19 16:19
     */
    @Override
    public String filterType() {
        return FilterConstants.PRE_TYPE;
    }
    /**
     * 功能描述: <br>过滤器的优先级，数字越小，优先级越高。PreDecorationFilter过滤器的优先级为5（PreDecorationFilter用于处理请求上下文），
     * 所以我们可以指定为6让我们的过滤器优先级比它低（这样才能拿到上下文）；
     * @Date: 2019/12/19 16:19
     */
    @Override
    public int filterOrder() {
        return 6;
    }
    /**
     * 功能描述: <br>方法返回boolean类型，true时表示是否执行该过滤器的run方法，false则表示不执行；
     * @Date: 2019/12/19 16:19
     */
    @Override
    public boolean shouldFilter() {
        return true;
    }
    /**
     * 功能描述: <br>定义过滤器的主要逻辑。这里我们通过请求上下文RequestContext获取了转发的服务名称serviceId和请求对象HttpServletRequest，
     * 并打印请求日志。随后往请求上下文的头部添加了Key为ZuulToken，Value为febs:zuul:123456的信息。这两个值可以抽取到常量类中。
     * @Date: 2019/12/19 16:19
     */
    @Override
    public Object run(){
        RequestContext requestContext = RequestContext.getCurrentContext();
        String serviceId = (String) requestContext.get(FilterConstants.SERVICE_ID_KEY);
        HttpServletRequest request = requestContext.getRequest();
        String host = request.getRemoteHost();
        String method = request.getMethod();
        String uri = request.getRequestURI();
        log.info("请求URI：{}，HTTP Method：{}，请求IP：{}，ServerId：{}", uri, method, host, serviceId);

        // 禁止外部访问资源
        boolean shouldForward = true;
        String forbidRequestUri = properties.getForbidRequestUri();
        String[] forbidRequestUris = StringUtils.splitByWholeSeparatorPreserveAllTokens(forbidRequestUri, ",");
        if (forbidRequestUris != null && ArrayUtils.isNotEmpty(forbidRequestUris)) {
            for (String u : forbidRequestUris) {
                if (pathMatcher.match(u, uri)) {
                    // 逐一判断客户端请求URI是否在禁止外部访问的范围内
                    shouldForward = false;
                }
            }
        }
        // 禁止访问则返回“该URI不允许外部访问”响应，状态码为403
        if (!shouldForward) {
            HttpServletResponse response = requestContext.getResponse();
            FebsResponse febsResponse = new FebsResponse().message("该URI不允许外部访问");
            try {
                FebsUtil.makeResponse(
                        response, MediaType.APPLICATION_JSON_UTF8_VALUE,
                        HttpServletResponse.SC_FORBIDDEN, febsResponse
                );
                requestContext.setSendZuulResponse(false);
                requestContext.setResponse(response);
            } catch (IOException e) {
                e.printStackTrace();
            }
            return null;
        }

        byte[] token = Base64Utils.encode((FebsConstant.ZUUL_TOKEN_VALUE).getBytes());
        requestContext.addZuulRequestHeader(FebsConstant.ZUUL_TOKEN_HEADER, new String(token));
        return null;
    }
}
```

> 关于Zuul Filter，参考 [Zuul Filter](https://blog.csdn.net/wo18237095579/article/details/83543592),能让你知道为什么order要设为6。

这里还加入了黑名单，和之前一样了，其实就是读取一个配置文件：

```java
package com.sunsas.febs.gateway.properties;

/**
 * 功能描述: <br>actuator提供的端点直接对外暴露了，这是非常不安全的，因为我们的服务都是通过微服务网关暴露出去的,
 * 所以可以在微服务网关里添加一些保护性的代码。基本思路是：这些端点都是以actuator暴露出去的，所以我们可以限制通过网关访问这些资源。
 * @return:
 * @Author: Lenovo
 * @Date: 2020/1/2 11:15
 */
@Data
@SpringBootConfiguration
@PropertySource(value = {"classpath:febs-gateway.properties"})
@ConfigurationProperties(prefix = "febs.gateway")
public class FebsGatewayProperties {
    /**
     * 禁止外部访问的 URI，多个值的话以逗号分隔
     */
    private String forbidRequestUri;
}
```
```
febs.gateway.forbidRequestUri=/**/actuator/**
```

这不是重点，我们通过`requestContext.addZuulRequestHeader`把token塞进header中，其中`FebsConstant`就是一个常量类

```
package com.sunsas.febs.common.entity;

public class FebsConstant {
    /**
     * Zuul请求头TOKEN名称（不要有空格）
     */
    public static final String ZUUL_TOKEN_HEADER = "ZuulToken";
    /**
     * Zuul请求头TOKEN值
     */
    public static final String ZUUL_TOKEN_VALUE = "febs:zuul:123456";
    /**
     * gif类型
     */
    public static final String GIF = "gif";
    /**
     * png类型
     */
    public static final String PNG = "png";

    /**
     * 验证码 key前缀
     */
    public static final String CODE_PREFIX = "febs.captcha.";
}

```
在此过滤器中往**请求上下文**的头部添加了**Key为ZuulToken，Value为febs:zuul:123456**的信息

#### 3.4.2 校验Zuul Token
由于各个微服务都需要进行拦截，我们在`febs-common`模块下新建interceptor包，然后在该包下新建`FebsServerProtectInterceptor`拦截器

```java
package com.sunsas.febs.common.interceptor;


/**
 * 功能描述: <br>定义好Zuul过滤器后，我们需要在各个微服务里定义一个全局拦截器拦截请求，并校验Zuul Token。
 * 这个拦截器需要被众多微服务模块使用，所以把它定义在通用模块febs-common里。
 * @Author: Lenovo
 * @Date: 2019/12/19 16:36
 */
public class FebsServerProtectInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String token = request.getHeader(FebsConstant.ZUUL_TOKEN_HEADER);
        String zuulToken = new String(Base64Utils.encode(FebsConstant.ZUUL_TOKEN_VALUE.getBytes()));
        if(StringUtils.equals(zuulToken,token)){
            return true;
        } else {
            FebsResponse febsResponse = new FebsResponse();
            response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write(JSONObject.toJSONString(febsResponse.message("请通过网关获取资源")));
            return false;
        }
    }
}
```
逻辑很简单，就是从请求头取出token，解码后对比，正确就放行，错误返回错误信息。

为了使此拦截器生效，需要定义一个配置类，将它注册到Spring IOC容器中，在febs-common模块新建`FebsServerProtectConfigure`

```java
package com.sunsas.febs.common.configure;

/**
 * 功能描述: <br>要让该过滤器(FebsServerProtectInterceptor)生效我们需要定义一个配置类来将它注册到Spring IOC容器中
 * @Author: Lenovo
 * @Date: 2019/12/19 16:52
 */
public class FebsServerProtectConfigure implements WebMvcConfigurer {
    @Bean
    @ConditionalOnMissingBean(value = PasswordEncoder.class)
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public HandlerInterceptor febsServerProtectInterceptor(){
        return new FebsServerProtectInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(febsServerProtectInterceptor());
    }
}
```


同样，要让别的微服务能够导入它放到自己的Spring 容器中，新建`@Enable`注解来驱动它。

```java
package com.sunsas.febs.common.annotation;

/**
 * 功能描述: <br>要让该配置类(FebsServerProtectConfigure)生效，我们可以定义一个@Enable注解来驱动它。
 * @Author: Lenovo
 * @Date: 2019/12/19 16:59
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(FebsServerProtectConfigure.class)
public @interface EnableFebsServerProtect {
}
```

**Feign拦截器里也加入Zuul Token，否则Feign调用微服务会报403异常**，就是之前的`FebsOAuth2FeignConfigure`
```java
// 添加 Zuul Token
String zuulToken = new String(Base64Utils.encode(FebsConstant.ZUUL_TOKEN_VALUE.getBytes()));
requestTemplate.header(FebsConstant.ZUUL_TOKEN_HEADER, zuulToken);
```


### 3.5 Enable接口的整合
`EnableFebsServerProtect`、`@EnableFebsOauth2FeignClient`和`@EnableFebsAuthExceptionHandler`是我们自定义的，它们的作用如下：

- @EnableFebsServerProtect，开启微服务防护，避免客户端绕过网关直接请求微服务；
- @EnableFebsOauth2FeignClient，开启带令牌的Feign请求，避免微服务内部调用出现401异常；
- @EnableFebsAuthExceptionHandler，认证类型异常翻译。

这三个功能都是微服务提供者必备的功能，所以我们可以**定义一个注解将这三个功能整合在一起**。

将这三个配置类一次性都注册到IOC容器中。在Spring中，要将多个类进行注册，**可以使用selector的方式**。

在febs-common模块下新建selector包，然后在该包下创`建FebsCloudApplicationSelector`：

```java
package com.sunsas.febs.common.selector;

/**
 * 功能描述: 此类就是将将 EnableFebsServerProtect、@EnableFebsOauth2FeignClient和@EnableFebsAuthExceptionHandler
 * 这三个配置类一次性都注册到IOC容器中。在Spring中，要将多个类进行注册，可以使用selector的方式。
 * @Author: Lenovo
 * @Date: 2019/12/19 18:35
 */
public class FebsCloudApplicationSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata annotationMetadata) {
        return new String[]{
                FebsAuthExceptionConfigure.class.getName(),
                FebsOAuth2FeignConfigure.class.getName(),
                FebsServerProtectConfigure.class.getName()
        };
    }
}
```

> selector会递归进行解析，把解析到的类全名按照@Configuration进行处理，源码级别可参考：[详解Spring的ImportSelector接口(2)](https://www.jianshu.com/p/23d4e853b15b)

现在需将FebsCloudApplicationSelector注册到IOC容器中，老做法，还是通过自定义注解：

```java
package com.sunsas.febs.common.annotation;

/**
 * 功能描述: <br>将FebsCloudApplicationSelector注册到IOC容器中
 * @Author: Lenovo
 * @Date: 2019/12/19 18:35
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(FebsCloudApplicationSelector.class)
public @interface FebsCloudApplication {
}
```

在需要的微服务启动类使用此注解即可。

### 3.5 网关解决跨域
跨域解决方法很多，因为我们的请求都是通过微服务网关来转发的，所以我们可以在网关处统一处理跨域。


```java
package com.sunsas.febs.gateway.configure;


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class FebsGateWayCorsConfigure {

    @Bean
    public CorsFilter corsFilter(){
        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        final CorsConfiguration corsConfiguration = new CorsConfiguration();
        /** setAllowCredentials(true)表示允许cookie跨域；
         addAllowedHeader(CorsConfiguration.ALL)表示请求头部允许携带任何内容；
         addAllowedOrigin(CorsConfiguration.ALL)表示允许任何来源；
         addAllowedMethod(CorsConfiguration.ALL)表示允许任何HTTP方法。*/
        corsConfiguration.setAllowCredentials(true);
        corsConfiguration.addAllowedHeader(CorsConfiguration.ALL);
        corsConfiguration.addAllowedOrigin(CorsConfiguration.ALL);
        corsConfiguration.addAllowedMethod(CorsConfiguration.ALL);
        source.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsFilter(source);
    }
}
```


---



## 5.2.4. 登录

### 4.1 建表
```mysql
CREATE TABLE `t_user`  (
  `USER_ID` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `USERNAME` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户名',
  `PASSWORD` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码',
  `DEPT_ID` bigint(20) NULL DEFAULT NULL COMMENT '部门ID',
  `EMAIL` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `MOBILE` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '联系电话',
  `STATUS` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '状态 0锁定 1有效',
  `CREATE_TIME` datetime(0) NOT NULL COMMENT '创建时间',
  `MODIFY_TIME` datetime(0) NULL DEFAULT NULL COMMENT '修改时间',
  `LAST_LOGIN_TIME` datetime(0) NULL DEFAULT NULL COMMENT '最近访问时间',
  `SSEX` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '性别 0男 1女 2保密',
  `AVATAR` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `DESCRIPTION` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`USER_ID`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;


INSERT INTO `t_user` VALUES (1, 'MrBird', '$2a$10$gzhiUb1ldc1Rf3lka4k/WOoFKKGPepHSzJxzcPSN5/65SzkMdc.SK', 1, 'mrbird@qq.com', '17788888888', '1', '2019-06-14 20:39:22', '2019-07-19 10:18:36', '2019-08-02 15:57:00', '0', 'default.jpg', '我是帅比作者。');

CREATE TABLE `t_role`  (
  `ROLE_ID` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `ROLE_NAME` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色名称',
  `REMARK` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '角色描述',
  `CREATE_TIME` datetime(0) NOT NULL COMMENT '创建时间',
  `MODIFY_TIME` datetime(0) NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`ROLE_ID`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色表' ROW_FORMAT = Dynamic;

INSERT INTO `t_role` VALUES (1, '管理员', '管理员', now(), now());

CREATE TABLE `t_menu`  (
  `MENU_ID` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '菜单/按钮ID',
  `PARENT_ID` bigint(20) NOT NULL COMMENT '上级菜单ID',
  `MENU_NAME` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '菜单/按钮名称',
  `PATH` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '对应路由path',
  `COMPONENT` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '对应路由组件component',
  `PERMS` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限标识',
  `ICON` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图标',
  `TYPE` char(2) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '类型 0菜单 1按钮',
  `ORDER_NUM` double(20, 0) NULL DEFAULT NULL COMMENT '排序',
  `CREATE_TIME` datetime(0) NOT NULL COMMENT '创建时间',
  `MODIFY_TIME` datetime(0) NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`MENU_ID`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '菜单表' ROW_FORMAT = Dynamic;


INSERT INTO `t_menu` VALUES (1, 0, '系统管理', '/system', 'Layout', NULL, 'el-icon-set-up', '0', 1, '2017-12-27 16:39:07', '2019-07-20 16:19:04');
INSERT INTO `t_menu` VALUES (2, 1, '用户管理', '/system/user', 'febs/system/user/Index', 'user:view', '', '0', 1, '2017-12-27 16:47:13', '2019-01-22 06:45:55');
INSERT INTO `t_menu` VALUES (3, 2, '新增用户', '', '', 'user:add', NULL, '1', NULL, '2017-12-27 17:02:58', NULL);
INSERT INTO `t_menu` VALUES (4, 2, '修改用户', '', '', 'user:update', NULL, '1', NULL, '2017-12-27 17:04:07', NULL);
INSERT INTO `t_menu` VALUES (5, 2, '删除用户', '', '', 'user:delete', NULL, '1', NULL, '2017-12-27 17:04:58', NULL);


CREATE TABLE `t_user_role`  (
  `USER_ID` bigint(20) NOT NULL COMMENT '用户ID',
  `ROLE_ID` bigint(20) NOT NULL COMMENT '角色ID'
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户角色关联表' ROW_FORMAT = Dynamic;

INSERT INTO `t_user_role` VALUES (1, 1);


CREATE TABLE `t_role_menu`  (
  `ROLE_ID` bigint(20) NOT NULL,
  `MENU_ID` bigint(20) NOT NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色菜单关联表' ROW_FORMAT = Dynamic;


INSERT INTO `t_role_menu` VALUES (1, 1);
INSERT INTO `t_role_menu` VALUES (1, 2);
INSERT INTO `t_role_menu` VALUES (1, 3);
INSERT INTO `t_role_menu` VALUES (1, 4);
INSERT INTO `t_role_menu` VALUES (1, 5);


CREATE TABLE `t_dept`  (
  `DEPT_ID` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '部门ID',
  `PARENT_ID` bigint(20) NOT NULL COMMENT '上级部门ID',
  `DEPT_NAME` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '部门名称',
  `ORDER_NUM` double(20, 0) NULL DEFAULT NULL COMMENT '排序',
  `CREATE_TIME` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `MODIFY_TIME` datetime(0) NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`DEPT_ID`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '部门表' ROW_FORMAT = Dynamic;

INSERT INTO `t_dept` VALUES (1, 0, '开发部', 1, '2018-01-04 15:42:26', '2019-01-05 21:08:27');
```

### 3.2 完善登录流程

#### 3.2.1 整合mybatis-plus

因为后续多个微服务系统需要用到MyBatis Plus，并且数据表对应的实体类是定义在febs-common模块里的，所以我们选择在febs-common模块里引入相应的MyBatis Plus依赖。

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.1.2</version>
</dependency>
```

在febs-auth模块的pom里引入MySQL连接驱动和MyBatis Plus多数据源依赖：

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>dynamic-datasource-spring-boot-starter</artifactId>
    <version>2.5.4</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```
在febs-auth模块的配置文件application.yml里添加多数据源以及mybatis-plus配置：

```
spring:
  datasource:
    dynamic:
      hikari:
        connection-timeout: 30000
        max-lifetime: 1800000
        max-pool-size: 15
        min-idle: 5
        connection-test-query: select 1
        pool-name: FebsHikariCP
      primary: base
      datasource:
        base:
          username: root
          password: 123456
          driver-class-name: com.mysql.cj.jdbc.Driver
          url: jdbc:mysql://localhost:3306/febs_cloud_base?useUnicode=true&characterEncoding=UTF-8&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=GMT%2b8
# mybatis-plus.type-aliases-package，指定别名扫描路径，这个路径后续在febs-common模块里定义，该路径下的实体类将自动配置别名，默认为类名首字母小写。配置别名后，便可以直接在MyBatis XML文件里使用了；
# mybatis-plus.mapper-locations指定MyBatis XML文件路径；
# mybatis-plus.configuration.jdbc-type-for-null，指定为null，否则再插入空值时会报“无效的列类型”错误；
# mybatis-plus.configuration.global-config.banner设置为false关闭MyBatis Plus Banner打印。
mybatis-plus:
  type-aliases-package: com.sunsas.febs.common.entity.system
  mapper-locations: classpath:mapper/*.xml
  configuration:
    jdbc-type-for-null: null
  global-config:
    banner: false
```
虽然使用了多数据源，不过我们的项目并没有用到，这里只配置了一个，如果想继续添加只需像**base**那样在`spring.datasource.dynamic.datasource`下继续添加即可

> 关于多数据源配置，参考 [springboot+druid+mybatis plus的多数据源配置](https://cloud.tencent.com/developer/article/1181415)


因为我们在febs-common模块里引入了mybatis-plus-boot-starter，该starter**包含数据库自动装配配置**，而febs-gateway、febs-server-system和febs-server-test模块并**没有配置数据库**，所以我们需要在它们的配置文件application.yml里添加如下配置来**关闭数据库自动装配**:

```
spring:
  autoconfigure:
    exclude: org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

后面可能会导入数据库，那就把它删了，也可能还有别的数据库，例如关闭redis装配。


#### 3.2.2 用户持久层

在febs-common模块新建`SystemUser`实体类，对应t_user用户表数据：

```java
package com.sunsas.febs.common.entity.system;

@Data
@TableName("t_user")
public class SystemUser {
    private static final long serialVersionUID = -4352868070794165001L;

    /** 用户状态：有效*/
    public static final String STATUS_VALID = "1";
    /** 用户状态：锁定*/
    public static final String STATUS_LOCK = "0";
    /** 默认头像*/
    public static final String DEFAULT_AVATAR = "default.jpg";
    /** 默认密码*/
    public static final String DEFAULT_PASSWORD = "1234qwer";
    /** 性别男*/
    public static final String SEX_MALE = "0";
    /** 性别女*/
    public static final String SEX_FEMALE = "1";
    /** 性别保密*/
    public static final String SEX_UNKNOWN = "2";

    /**
     * 用户 ID
     */
    @TableId(value = "USER_ID", type = IdType.AUTO)
    private Long userId;

    /**
     * 用户名
     */
    @TableField("USERNAME")
    @Size(min = 4, max = 10, message = "{range}")
    private String username;

    /**
     * 密码
     */
    @TableField("PASSWORD")
    private String password;

    /**
     * 部门 ID
     */
    @TableField("DEPT_ID")
    private Long deptId;

    /**
     * 邮箱
     */
    @TableField("EMAIL")
    @Size(max = 50, message = "{noMoreThan}")
    @Email(message = "{email}")
    private String email;

    /**
     * 联系电话
     * @IsMobile 自定义参数校验注解
     */
    @TableField("MOBILE")
    @IsMobile(message = "{mobile}")
    private String mobile;

    /**
     * 状态 0锁定 1有效
     */
    @TableField("STATUS")
    @NotBlank(message = "{required}")
    private String status;

    /**
     * 创建时间
     */
    @TableField("CREATE_TIME")
    private Date createTime;

    /**
     * 修改时间
     */
    @TableField("MODIFY_TIME")
    private Date modifyTime;

    /**
     * 最近访问时间
     */
    @TableField("LAST_LOGIN_TIME")
    private Date lastLoginTime;

    /**
     * 性别 0男 1女 2 保密
     */
    @TableField("SSEX")
    @NotBlank(message = "{required}")
    private String sex;

    /**
     * 头像
     */
    @TableField("AVATAR")
    private String avatar;

    /**
     * 描述
     */
    @TableField("DESCRIPTION")
    @Size(max = 100, message = "{noMoreThan}")
    private String description;

    /**
     * 部门名称
     */
    @TableField(exist = false)
    private String deptName;
    /** @TableField(exist = false)表示非数据表字段，非数据表字段一般用于拓展查询结果； */
    @TableField(exist = false)
    private String createTimeFrom;
    @TableField(exist = false)
    private String createTimeTo;
    /**
     * 角色 ID
     */
    @TableField(exist = false)
    private String roleId;

    @TableField(exist = false)
    private String roleName;
}

```

@TableName("t_user")注解用于指定对应数据表的表名；@TableField用于指定数据表字段名称；**@TableField**(exist = false)表示**非数据表字段**，非数据表字段一般用于拓展查询结果；也可以使用**transient**关键字。

新建Menu实体类，对应t_menu数据表：

```java
package com.sunsas.febs.common.entity.system;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;

import java.util.Date;

@Data
@TableName("t_menu")
public class Menu {
    private static final long serialVersionUID = 7187628714679791771L;

    // 菜单
    public static final String TYPE_MENU = "0";
    // 按钮
    public static final String TYPE_BUTTON = "1";

    /**
     * 菜单/按钮ID
     */
    @TableId(value = "MENU_ID", type = IdType.AUTO)
    private Long menuId;

    /**
     * 上级菜单ID
     */
    @TableField("PARENT_ID")
    private Long parentId;

    /**
     * 菜单/按钮名称
     */
    @TableField("MENU_NAME")
    private String menuName;

    /**
     * 菜单URL
     */
    @TableField("PATH")
    private String path;

    /**
     * 对应 Vue组件
     */
    @TableField("COMPONENT")
    private String component;

    /**
     * 权限标识
     */
    @TableField("PERMS")
    private String perms;

    /**
     * 图标
     */
    @TableField("ICON")
    private String icon;

    /**
     * 类型 0菜单 1按钮
     */
    @TableField("TYPE")
    private String type;

    /**
     * 排序
     */
    @TableField("ORDER_NUM")
    private Integer orderNum;

    /**
     * 创建时间
     */
    @TableField("CREATE_TIME")
    private Date createTime;

    /**
     * 修改时间
     */
    @TableField("MODIFY_TIME")
    private Date modifyTime;

    private transient String createTimeFrom;
    private transient String createTimeTo;
}
```

在在febs-auth模块创建mapper：

```java
package com.sunsas.febs.auth.mapper;

public interface UserMapper extends BaseMapper<SystemUser> {
    SystemUser findByName(String username);
}
```

```java
package com.sunsas.febs.auth.mapper;

public interface MenuMapper extends BaseMapper<Menu> {
    List<Menu> findUserPermissions(String username);
}
```
继承了`BaseMapper`就可以使用它自带的方法了，不过我们还是需要自定义一些复杂的查询。

在febs-auth模块的resources路径下新建mapper包，这个路径对应application.yml里配置的`mybatis-plus.mapper-locations: classpath:mapper/*.xml`
新建UserMapper.xml和MenuMapper.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.sunsas.febs.auth.mapper.UserMapper">
    <select id="findByName" parameterType="string" resultType="com.sunsas.febs.common.entity.system.SystemUser">
        SELECT
        u.user_id userId,
        u.username,
        u.email,
        u.mobile,
        u.password,
        u.status,
        u.create_time createTime,
        u.ssex sex,
        u.dept_id deptId,
        u.last_login_time lastLoginTime,
        u.modify_time modifyTime,
        u.description,
        u.avatar,
        d.dept_name deptName,
        GROUP_CONCAT(r.role_id) roleId,
        GROUP_CONCAT(r.ROLE_NAME) roleName
        FROM
        t_user u
        LEFT JOIN t_dept d ON (u.dept_id = d.dept_id)
        LEFT JOIN t_user_role ur ON (u.user_id = ur.user_id)
        LEFT JOIN t_role r ON r.role_id = ur.role_id
        WHERE  u.username = #{username}
        group by u.username,u.user_id,u.email,u.mobile,u.password, u.status,u.create_time,u.ssex,u.dept_id
				,u.last_login_time,u.modify_time,u.description,u.avatar
    </select>
</mapper>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.sunsas.febs.auth.mapper.MenuMapper">
    <select id="findUserPermissions" resultType="menu">
        select distinct m.perms
        from t_role r
                 left join t_user_role ur on (r.role_id = ur.role_id)
                 left join t_user u on (u.user_id = ur.user_id)
                 left join t_role_menu rm on (rm.role_id = r.role_id)
                 left join t_menu m on (m.menu_id = rm.menu_id)
        where u.username = #{userName}
          and m.perms is not null
          and m.perms &lt;&gt; ''
    </select>
</mapper>
```
不知为何，别名貌似不行，idea中报红，不过不影响使用？

然后启动类加上扫描mapper接口的注解：
`@MapperScan("com.sunsas.febs.auth.mapper")`

在febs-auth模块新建manager包，在该包下新建`UserManager`（其实就是service层），用于统一定义和用户相关的业务方法
```java
package com.sunsas.febs.auth.manager;

@Service
public class UserManager {
    /** idea报错，其实没错，不用理*/
    @Autowired
    private UserMapper userMapper;
    @Autowired
    private MenuMapper menuMapper;

    public SystemUser findByName(String username) {
        return userMapper.findByName(username);
    }

    public String findUserPermissions(String username){
        List<Menu> userPermissions = menuMapper.findUserPermissions(username);
//        List<String> perms = new ArrayList<>();
//        for (Menu m: userPermissions){
//            perms.add(m.getPerms());
//        }
//        return StringUtils.join(perms, ",");
        return userPermissions.stream().map(Menu::getPerms).collect(Collectors.joining(","));
    }
}
```

然后改造`FebsUserDetailService`，因为之前的用户是我们伪造的，现在将它改造为通过查询数据库的方式获取：

```java
package com.sunsas.febs.auth.service;

import com.alibaba.fastjson.JSON;
import com.sunsas.febs.auth.manager.UserManager;
import com.sunsas.febs.auth.mapper.UserMapper;
import com.sunsas.febs.common.entity.FebsAuthUser;
import com.sunsas.febs.common.entity.system.SystemUser;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class FebsUserDetailService implements UserDetailsService {
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private UserManager userManager;
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        SystemUser systemUser = userManager.findByName(username);
        if(systemUser != null){
            String permissions = userManager.findUserPermissions(systemUser.getUsername());
            boolean notLocked = false;
            if (StringUtils.equals(SystemUser.STATUS_VALID, systemUser.getStatus())){
                notLocked = true;
            }
            FebsAuthUser authUser = new FebsAuthUser(systemUser.getUsername(), systemUser.getPassword(), true, true, true, notLocked,
                    AuthorityUtils.commaSeparatedStringToAuthorityList(permissions));
            BeanUtils.copyProperties(systemUser, authUser);
            return authUser;
        } else {
            throw new UsernameNotFoundException("");
        }
    }

//    private FebsAuthUser  transSystemUserToAuthUser(FebsAuthUser authUser, SystemUser systemUser) {
//        authUser = JSON.parseObject(JSON.toJSONString(systemUser),FebsAuthUser.class);
//        return authUser;
//    }
}
```
`BeanUtils.copyProperties(systemUser, authUser);`也可以使用Json去复制，就是下面注释的那个方法

我们访问 localhost:8301/auth/oauth/token?grant_type=password&username=sunsas&password=1234qwer 获取token，然后携带token访问 localhost:8301/auth/user 此接口能获取spring security在线用户信息；

```
// principal 可以直接作为方法参数，框架会自动赋值。
@GetMapping("user")
public Principal currentUser(Principal principal) {
    return principal;
}
```

> 关于获得spring security在线用户信息，参考： [spring security 获取用户信息](https://blog.csdn.net/neweastsun/article/details/79337478)



### 3.3 整合图形验证码

图形验证码是最简单的人机校验手段,就是每次登录都需要携带验证码过来，可以有效的防止恶意程序暴力破解登录密码

Spring Security本质是一长串的过滤器链，要集成图形验证码校验很简单，只需要在`UsernamePasswordAuthenticationFilter`过滤器（处理用户名密码登录的过滤器）前添加图形验证码校验过滤器即可。

#### 3.3.1 Lettuce

验证码存在redis，我们使用Lettuce来操作redis。Lettuce基于Netty异步，拥有更好的性能.
> [Redis高级客户端Lettuce详解 ](https://www.cnblogs.com/throwable/p/11601538.html)

在febs-auth模块的pom里添加`commons-pool2 Lettuce`连接池依赖

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

在febs-common模块定义一个Redis服务类，用于封装常用的Redis操作方法(太长了，真不想放啊):

```java
package com.sunsas.febs.common.service;

public class RedisService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * 指定缓存失效时间
     *
     * @param key  键
     * @param time 时间(秒)
     * @return Boolean
     */
    public Boolean expire(String key, Long time) {
        try {
            if (time > 0) {
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据key获取过期时间
     *
     * @param key 键 不能为 null
     * @return 时间(秒) 返回 0代表为永久有效
     */
    public Long getExpire(String key) {
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }

    /**
     * 判断 key是否存在
     *
     * @param key 键
     * @return true 存在 false不存在
     */
    public Boolean hasKey(String key) {
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除缓存
     *
     * @param key 可以传一个值 或多个
     */
    public void del(String... key) {
        if (key != null && key.length > 0) {
            if (key.length == 1) {
                redisTemplate.delete(key[0]);
            } else {
                redisTemplate.delete(Arrays.asList(key));
            }
        }
    }

    /**
     * 普通缓存获取
     *
     * @param key 键
     * @return 值
     */
    public Object get(String key) {
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     *
     * @param key   键
     * @param value 值
     * @return true成功 false失败
     */
    public Boolean set(String key, Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 普通缓存放入并设置时间
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */
    public Boolean set(String key, Object value, Long time) {
        try {
            if (time > 0) {
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            } else {
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 递增
     *
     * @param key   键
     * @param delta 要增加几(大于0)
     * @return Long
     */
    public Long incr(String key, Long delta) {
        if (delta < 0) {
            throw new RuntimeException("递增因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }

    /**
     * 递减
     *
     * @param key   键
     * @param delta 要减少几(小于0)
     * @return Long
     */
    public Long decr(String key, Long delta) {
        if (delta < 0) {
            throw new RuntimeException("递减因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }

    /**
     * HashGet
     *
     * @param key  键 不能为 null
     * @param item 项 不能为 null
     * @return 值
     */
    public Object hget(String key, String item) {
        return redisTemplate.opsForHash().get(key, item);
    }

    /**
     * 获取 hashKey对应的所有键值
     *
     * @param key 键
     * @return 对应的多个键值
     */
    public Map<Object, Object> hmget(String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * HashSet
     *
     * @param key 键
     * @param map 对应多个键值
     * @return true 成功 false 失败
     */
    public Boolean hmset(String key, Map<String, Object> map) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * HashSet 并设置时间
     *
     * @param key  键
     * @param map  对应多个键值
     * @param time 时间(秒)
     * @return true成功 false失败
     */
    public Boolean hmset(String key, Map<String, Object> map, Long time) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            if (time > 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @return true 成功 false失败
     */
    public Boolean hset(String key, String item, Object value) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public Boolean hset(String key, String item, Object value, Long time) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            if (time > 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除hash表中的值
     *
     * @param key  键 不能为 null
     * @param item 项 可以使多个不能为 null
     */
    public void hdel(String key, Object... item) {
        redisTemplate.opsForHash().delete(key, item);
    }

    /**
     * 判断hash表中是否有该项的值
     *
     * @param key  键 不能为 null
     * @param item 项 不能为 null
     * @return true 存在 false不存在
     */
    public Boolean hHasKey(String key, String item) {
        return redisTemplate.opsForHash().hasKey(key, item);
    }

    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     *
     * @param key  键
     * @param item 项
     * @param by   要增加几(大于0)
     * @return Double
     */
    public Double hincr(String key, String item, Double by) {
        return redisTemplate.opsForHash().increment(key, item, by);
    }

    /**
     * hash递减
     *
     * @param key  键
     * @param item 项
     * @param by   要减少几(小于0)
     * @return Double
     */
    public Double hdecr(String key, String item, Double by) {
        return redisTemplate.opsForHash().increment(key, item, -by);
    }

    /**
     * 根据 key获取 Set中的所有值
     *
     * @param key 键
     * @return Set
     */
    public Set<Object> sGet(String key) {
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 根据value从一个set中查询,是否存在
     *
     * @param key   键
     * @param value 值
     * @return true 存在 false不存在
     */
    public Boolean sHasKey(String key, Object value) {
        try {
            return redisTemplate.opsForSet().isMember(key, value);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将数据放入set缓存
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public Long sSet(String key, Object... values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0L;
        }
    }
    /**
     * 将set数据放入缓存
     *
     * @param key    键
     * @param time   时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public Long sSetAndTime(String key, Long time, Object... values) {
        try {
            Long count = redisTemplate.opsForSet().add(key, values);
            if (time > 0) {
                expire(key, time);
            }
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0L;
        }
    }

    /**
     * 获取set缓存的长度
     *
     * @param key 键
     * @return Long
     */
    public Long sGetSetSize(String key) {
        try {
            return redisTemplate.opsForSet().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0L;
        }
    }

    /**
     * 移除值为value的
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 移除的个数
     */
    public Long setRemove(String key, Object... values) {
        try {
            return redisTemplate.opsForSet().remove(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0L;
        }
    }

    /**
     * 获取list缓存的内容
     *
     * @param key   键
     * @param start 开始
     * @param end   结束 0 到 -1代表所有值
     * @return List
     */
    public List<Object> lGet(String key, Long start, Long end) {
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 获取list缓存的长度
     *
     * @param key 键
     * @return Long
     */
    public Long lGetListSize(String key) {
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0L;
        }
    }

    /**
     * 通过索引 获取list中的值
     *
     * @param key   键
     * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；
     *              index<0时，-1，表尾，-2倒数第二个元素，依次类推
     * @return Object
     */
    public Object lGetIndex(String key, Long index) {
        try {
            return redisTemplate.opsForList().index(key, index);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @return Boolean
     */
    public Boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return Boolean
     */
    public Boolean lSet(String key, Object value, Long time) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            if (time > 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @return Boolean
     */
    public Boolean lSet(String key, List<Object> value) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return Boolean
     */
    public Boolean lSet(String key, List<Object> value, Long time) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            if (time > 0){
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据索引修改list中的某条数据
     *
     * @param key   键
     * @param index 索引
     * @param value 值
     * @return Boolean
     */
    public Boolean lUpdateIndex(String key, Long index, Object value) {
        try {
            redisTemplate.opsForList().set(key, index, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 移除N个值为value
     *
     * @param key   键
     * @param count 移除多少个
     * @param value 值
     * @return 移除的个数
     */
    public Long lRemove(String key, Long count, Object value) {
        try {
            return redisTemplate.opsForList().remove(key, count, value);
        } catch (Exception e) {
            e.printStackTrace();
            return 0L;
        }
    }
}
```

然后我们在febs-common模块下新建`FebsLettuceRedisConfigure`配置类，主要**设置往redis写数据的序列化方式**：

```java
package com.sunsas.febs.common.configure;

/**
 * 功能描述: <br>设置这个RedisTemplate在往Redis里写数据时key及value的序列化方式
 * （默认使用的JdkSerializationRedisSerializer这样的会导致我们通过Redis Desktop Manager显示的我们key跟value的时候为不可读字符串）。
 * 自定义了一个泛型为<String, Object>的RedisTemplate，指定key序列化策略采用StringRedisSerializer，value序列化策略采用Jackson2JsonRedisSerializer，
 * 其内部采用ObjectMapper（不熟悉ObjectMapper的同学可以参考Spring Boot中的JSON技术）来序列化对象。
 * @ConditionalOnClass(RedisOperations.class)表示只有当项目里存在RedisOperations类的时候
 * （即引入了spring-boot-starter-data-redis依赖的时候），我们自定义的RedisTemplateBean才会被注册到IOC容器中；
 * 将定义的RedisService注册到IOC容器中，前提是IOC容器里存在名称为redisTemplate的Bean。
 * @Author: Lenovo
 * @Date: 2019/12/20 16:08
 */
public class FebsLettuceRedisConfigure {
    @Bean
    @ConditionalOnClass(RedisOperations.class)
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<Object>(Object.class);
        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(mapper);

        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        // key采用 String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        // hash的 key也采用 String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        // value序列化方式采用 jackson
        template.setValueSerializer(jackson2JsonRedisSerializer);
        // hash的 value序列化方式采用 jackson
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();

        return template;
    }

    @Bean
    @ConditionalOnBean(name = "redisTemplate")
    public RedisService redisService() {
        return new RedisService();
    }
}

```

和之前一样，我们需要使此配置类在其余服务生效，可使用自定义注解：

```java
package com.sunsas.febs.common.annotation;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(FebsLettuceRedisConfigure.class)
public @interface EnableFebsLettuceRedis {
}
```

然后只要在febs-auth项目启动类加上注解`@EnableFebsLettuceRedis`

application.yml添加lettuce属性：

```
spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
    lettuce:
      pool:
        min-idle: 8
        max-idle: 500
        max-active: 2000
        max-wait: 10000
    timeout: 5000
```

#### 3.3.2 生成图形验证码
生成图形验证码可以借助GitHub的一个开源项目[easy-captcha](https://github.com/whvcse/EasyCaptcha)

在febs-auth的pom里引入该依赖：

```xml
<dependency>
    <groupId>com.github.whvcse</groupId>
    <artifactId>easy-captcha</artifactId>
    <version>1.6.2</version>
</dependency>
```

在febs-auth模块创建一个验证码属性配置类

```java
package com.sunsas.febs.auth.properties;

@Data
public class FebsValidateCodeProperties {
    /**
     * 验证码有效时间，单位秒
     */
    private Long time = 120L;
    /**
     * 验证码类型，可选值 png和 gif
     */
    private String type = "png";
    /**
     * 图片宽度，px
     */
    private Integer width = 130;
    /**
     * 图片高度，px
     */
    private Integer height = 48;
    /**
     * 验证码位数
     */
    private Integer length = 4;
    /**
     * 验证码值的类型
     * 1. 数字加字母
     * 2. 纯数字
     * 3. 纯字母
     */
    private Integer charType = 2;
}

```
在`FebsAuthProperties`配置类里引入验证码配置类,`febs-auth.properties`配置文件里添加验证码配置

```java
//验证码配置类
private FebsValidateCodeProperties code = new FebsValidateCodeProperties();
```
```
febs.auth.code.time=120
febs.auth.code.type=png
febs.auth.code.width=115
febs.auth.code.height=42
febs.auth.code.length=4
febs.auth.code.charType=2
```

在febs-common模块定义一个验证码类型异常`ValidateCodeException`:

```
package com.sunsas.febs.common.exception;

public class ValidateCodeException extends Exception {
    private static final long serialVersionUID = 7514854456967620043L;

    public ValidateCodeException(String message){
        super(message);
    }
}
```
在febs-auth模块的新建ValidateCodeService验证码服务类：

```java
package com.sunsas.febs.auth.service;

@Service
public class ValidateCodeService {
    @Autowired
    private RedisService redisService;
    @Autowired
    private FebsAuthProperities properities;
    /**
     * 功能描述: <br>生成验证码,key值功能类似sessionId，标识客户端，Redis Key为febs.captcha. + 客户端上送的key值，有效时间为配置文件定义的120秒
     * @Author: Lenovo
     * @Date: 2019/12/20 17:17
     */
    public void create(HttpServletRequest request, HttpServletResponse response) throws IOException, ValidateCodeException{
        String key = request.getParameter("key");
        if(StringUtils.isBlank(key)){
            throw new ValidateCodeException("验证码key不能为空");
        }
        FebsValidateCodeProperties code = properities.getCode();
        setHeader(response, code.getType());
        // 根据验证码配置文件生成验证码
        Captcha captcha =createCaptcha(code);
        // 将验证码字符保存到了Redis中
        redisService.set(FebsConstant.CODE_PREFIX + key,StringUtils.lowerCase(captcha.text()), code.getTime());
        // 将验证码图片以流的形式返回给客户端。
        captcha.out(response.getOutputStream());
    }

    /**
     * 功能描述: 用于校验验证码
     */
    public void check(String key, String value) throws ValidateCodeException {
        Object codeInRedis = redisService.get(FebsConstant.CODE_PREFIX + key);
        if (StringUtils.isBlank(value)) {
            throw new ValidateCodeException("请输入验证码");
        }
        if (codeInRedis == null) {
            throw new ValidateCodeException("验证码已过期");
        }
        if (!StringUtils.equalsIgnoreCase(value, String.valueOf(codeInRedis))) {
            throw new ValidateCodeException("验证码不正确");
        }
    }

    /**
     * 功能描述: <br>用于设置响应头。在生成验证码图片后我们需要将其返回到客户端，所以需要根据不同的验证码格式设置不同的响应头
     * @Author: Lenovo
     * @Date: 2019/12/20 17:45
     */
    private void setHeader(HttpServletResponse response, String type){
        if(StringUtils.equalsIgnoreCase(type, FebsConstant.GIF)){
            response.setContentType(MediaType.IMAGE_GIF_VALUE);
        } else {
            response.setContentType(MediaType.IMAGE_PNG_VALUE);
        }
        response.setHeader(HttpHeaders.PRAGMA,"No-cache");
        response.setHeader(HttpHeaders.CACHE_CONTROL,"no-cache");
        response.setDateHeader(HttpHeaders.EXPIRES, 0L);
    }

    /**
     * 功能描述: <br>方法通过验证码配置文件FebsValidateCodeProperties生成相应的验证码，比如PNG格式的或者GIF格式的，
     * 验证码图片的长宽高，验证码字符的类型（纯数字，纯字母或者数字字母组合），验证码字符的长度等
     * @Author: Lenovo
     * @Date: 2019/12/20 17:45
     */
    private Captcha createCaptcha(FebsValidateCodeProperties code){
        Captcha captcha = null;
        if (StringUtils.equalsIgnoreCase(code.getType(), FebsConstant.GIF)) {
            captcha = new GifCaptcha(code.getWidth(), code.getHeight(), code.getLength());
        } else {
            captcha = new SpecCaptcha(code.getWidth(), code.getHeight(), code.getLength());
        }
        captcha.setCharType(code.getCharType());
        return captcha;
    }
}
```

febs-auth模块下的`SecurityController`增加接口。
```java
@Autowired
private ValidateCodeService validateCodeService;

@GetMapping("captcha")
public void captcha(HttpServletRequest request, HttpServletResponse response) throws IOException, ValidateCodeException {
    validateCodeService.create(request, response);
}
```

之前说过我们把验证码获取服务路径放入白名单，因为这时候肯定还没有token的。  
在febs-auth.properties配置文件里添加免认证资源：
`febs.auth.anonUrl=/captcha`

#### 3.3.3 验证码校验
在febs-auth模块新增ValidateCodeFilter过滤器：

```java
package com.sunsas.febs.auth.filter;

/**
 * 验证码过滤器: ValidateCodeFilter继承Spring Boot提供的OncePerRequestFilter，
 * 该过滤器实现了javax.servlet.filter接口，顾名思义，它可以确保我们的逻辑只被执行一次。
 * 要注意将此过滤器放到验证登陆密码过滤器之前，FebsSecurityConfigure中addFilterBefore
 */
@Slf4j
@Component
public class ValidateCodeFilter extends OncePerRequestFilter {
    @Autowired
    private ValidateCodeService validateCodeService;

    @Override
    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {
        String header = httpServletRequest.getHeader("Authorization");
        String clientId = getClientId(header, httpServletRequest);

        RequestMatcher matcher = new AntPathRequestMatcher("/oauth/token", HttpMethod.POST.toString());
        if (matcher.matches(httpServletRequest)
                && StringUtils.equalsIgnoreCase(httpServletRequest.getParameter("grant_type"), "password")
                && !StringUtils.equalsIgnoreCase(clientId, "swagger")) {
            // 请求方法为POST并且请求参数grant_type为password的时候（对应密码模式获取令牌请求），需要进行验证码校验。
            // 验证码校验调用的是之前定义的ValidateCodeService的check方法。当验证码调用通过时调用
            try {
                validateCode(httpServletRequest);
                filterChain.doFilter(httpServletRequest, httpServletResponse);
            } catch (ValidateCodeException e) {
                FebsResponse febsResponse = new FebsResponse();
                FebsUtil.makeResponse(httpServletResponse, MediaType.APPLICATION_JSON_UTF8_VALUE,
                        HttpServletResponse.SC_INTERNAL_SERVER_ERROR, febsResponse.message(e.getMessage()));
                log.error(e.getMessage(), e);
            }
        } else {
            filterChain.doFilter(httpServletRequest, httpServletResponse);
        }
    }

    private void validateCode(HttpServletRequest request) throws ValidateCodeException {
        String code = request.getParameter("code");
        String key = request.getParameter("key");
        validateCodeService.check(key, code);
    }

    /**
     * 功能描述: <br>这个方法用于从请求头部获取ClientId信息，这段代码是从Spring Cloud OAuth2源码中拷贝过来的，
     * 所以看不懂没关系，只要知道它的作用就行了。
     * @param header
     * @param httpServletRequest
     * @return: java.lang.String
     * @Author: Lenovo
     * @Date: 2019/12/31 15:17
     */
    private String getClientId(String header, HttpServletRequest httpServletRequest) {
        String clientId = "";
        try {
            byte[] base64Token = header.substring(6).getBytes(StandardCharsets.UTF_8);
            byte[] decoded;
            decoded = Base64.getDecoder().decode(base64Token);

            String token = new String(decoded, StandardCharsets.UTF_8);
            int delim = token.indexOf(":");
            if (delim != -1) {
                clientId = new String[]{token.substring(0, delim), token.substring(delim + 1)}[0];
            }
        } catch (Exception ignore) {
        }
        return clientId;
    }

}

```
clientId是校验swagger的，这里可以删了。

要将ValidateCodeFilter过滤器添加到Spring Security过滤器链中，并且位于`UsernamePasswordAuthenticationFilter`过滤器前（即校验用户名密码时先校验验证码）。Spring security中使用`addFilterBefore()`方法（不清楚为何不使用order，可能UsernamePasswordAuthenticationFilter没有order？）

```java
@Order(2)
@EnableWebSecurity
public class FebsSecurityConfigure extends WebSecurityConfigurerAdapter {
    ......
    
    @Autowired
    private ValidateCodeFilter validateCodeFilter;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 通过http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)代码，
        // 将ValidateCodeFilter过滤器添加到了UsernamePasswordAuthenticationFilter过滤器前。
        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)
                .requestMatchers()
                .antMatchers("/oauth/**")
                .and()
                .authorizeRequests()
                .antMatchers("/oauth/**").authenticated()
                .and()
                .csrf().disable();
    }
    ......
}
```

在浏览器里访问 http://localhost:8301/auth/captcha?key=777774396 可获得验证码（key随意取）


### 3.4 Sentinel限流
由于验证码服务免认证，所以我们需要给**验证码限流**

这里使用阿里巴巴开源的**Sentinel流量哨兵**（网关中整合）


在febs-gateway模块的pom里引入如下依赖：

```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-zuul-adapter</artifactId>
    <version>1.6.3</version>
</dependency>
```

```java
package com.sunsas.febs.gateway.filter;

import com.alibaba.csp.sentinel.adapter.gateway.common.SentinelGatewayConstants;
import com.alibaba.csp.sentinel.adapter.gateway.common.api.ApiDefinition;
import com.alibaba.csp.sentinel.adapter.gateway.common.api.ApiPathPredicateItem;
import com.alibaba.csp.sentinel.adapter.gateway.common.api.ApiPredicateItem;
import com.alibaba.csp.sentinel.adapter.gateway.common.api.GatewayApiDefinitionManager;
import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayFlowRule;
import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayParamFlowItem;
import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayRuleManager;
import com.alibaba.csp.sentinel.adapter.gateway.zuul.fallback.ZuulBlockFallbackManager;
import com.alibaba.csp.sentinel.adapter.gateway.zuul.filters.SentinelZuulErrorFilter;
import com.alibaba.csp.sentinel.adapter.gateway.zuul.filters.SentinelZuulPostFilter;
import com.alibaba.csp.sentinel.adapter.gateway.zuul.filters.SentinelZuulPreFilter;
import com.netflix.zuul.ZuulFilter;
import com.sunsas.febs.gateway.fallback.FebsGatewayBlockFallbackProvider;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;
import java.util.HashSet;
import java.util.Set;

/**
 * 功能描述: <br>Sentinel流量哨兵来限制验证码的获取频率。
 * @Author: Lenovo
 * @Date: 2019/12/25 18:51
 */
@Slf4j
@Configuration
public class FebsGatewaySentinelFilter {

    @Bean
    public ZuulFilter sentinelZuulPreFilter() {
        return new SentinelZuulPreFilter();
    }

    @Bean
    public ZuulFilter sentinelZuulPostFilter() {
        return new SentinelZuulPostFilter();
    }

    @Bean
    public ZuulFilter sentinelZuulErrorFilter() {
        return new SentinelZuulErrorFilter();
    }

    @PostConstruct
    public void doInit() {
        ZuulBlockFallbackManager.registerProvider(new FebsGatewayBlockFallbackProvider());
        initGatewayRules();
    }

    /**
     * 功能描述: <br>定义验证码请求限流，限流规则：
     *  60秒内同一个IP，同一个 key最多访问 10次
     * @Author: Lenovo
     * @Date: 2019/12/25 18:46
     */
    private void initGatewayRules() {
        Set<ApiDefinition> definitions = new HashSet<>();
        Set<ApiPredicateItem> predicateItems = new HashSet<>();

        /**
         * 1.GatewayFlowRule：网关限流规则，针对 API Gateway 的场景定制的限流规则，可以针对不同 route 或
         *      自定义的 API 分组进行限流，支持针对请求中的参数、Header、来源 IP 等进行定制化的限流。
         * 2.ApiDefinition：用户自定义的 API 定义分组，可以看做是一些 URL 匹配的组合。
         *      比如我们可以定义一个 API 叫 my_api，请求 path 模式为 /foo/** 和 /baz/** 的都归到 my_api 
         *      这个 API 分组下面。限流的时候可以针对这个自定义的 API 分组维度进行限流。
         */
        predicateItems.add(new ApiPathPredicateItem().setPattern("/auth/captcha"));
        ApiDefinition definition = new ApiDefinition("captcha").setPredicateItems(predicateItems);
        definitions.add(definition);
        GatewayApiDefinitionManager.loadApiDefinitions(definitions);

        Set<GatewayFlowRule> rules = new HashSet<>();

        /**
         * resource：资源名称，可以是网关中的 route 名称或者用户自定义的 API 分组名称。
         * resourceMode：规则是针对 API Gateway 的 route（RESOURCE_MODE_ROUTE_ID）还是用户在 Sentinel 中定义的 API 分组（RESOURCE_MODE_CUSTOM_API_NAME），默认是 route。
         * count：限流阈值
         * intervalSec：统计时间窗口，单位是秒，默认是 1 秒。
         * paramItem：参数限流配置。若不提供，则代表不针对参数进行限流，该网关规则将会被转换成普通流控规则；否则会转换成热点规则。其中的字段：
         *  parseStrategy：从请求中提取参数的策略，目前支持提取来源 IP（PARAM_PARSE_STRATEGY_CLIENT_IP）、Host（PARAM_PARSE_STRATEGY_HOST）、
         *  任意 Header（PARAM_PARSE_STRATEGY_HEADER）和任意 URL 参数（PARAM_PARSE_STRATEGY_URL_PARAM）四种模式。
         *  fieldName：若提取策略选择 Header 模式或 URL 参数模式，则需要指定对应的 header 名称或 URL 参数名称。
         *  pattern：参数值的匹配模式，只有匹配该模式的请求属性值会纳入统计和流控；若为空则统计该请求属性的所有值。（1.6.2 版本开始支持）
         *  matchStrategy：参数值的匹配策略，目前支持精确匹配（PARAM_MATCH_STRATEGY_EXACT）、子串匹配（PARAM_MATCH_STRATEGY_CONTAINS）和正则匹配（PARAM_MATCH_STRATEGY_REGEX）。（1.6.2 版本开始支持）
         *
         * */
         rules.add(new GatewayFlowRule("captcha")
                .setResourceMode(SentinelGatewayConstants.RESOURCE_MODE_CUSTOM_API_NAME)
                .setParamItem(
                        new GatewayParamFlowItem()
                                .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_URL_PARAM)
                                .setFieldName("key")
                                .setMatchStrategy(SentinelGatewayConstants.PARAM_MATCH_STRATEGY_EXACT)
                                .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_CLIENT_IP)
                )
                .setCount(10)
                .setIntervalSec(60)
        );
        GatewayRuleManager.loadRules(rules);
    }
}

```

`FebsGatewayBlockFallbackProvider`是自定义异常响应

```java
package com.sunsas.febs.gateway.fallback;

public class FebsGatewayBlockFallbackProvider implements ZuulBlockFallbackProvider {
    @Override
    public String getRoute() {
        return "*";
    }

    @Override
    public BlockResponse fallbackResponse(String s, Throwable throwable) {
        if(throwable instanceof BlockException){
            return new BlockResponse(HttpStatus.TOO_MANY_REQUESTS.value(), "访问频率受限", s);
        } else {
            return new BlockResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), "系统异常", s);
        }
    }
}
```

> 参考
>
> [spring security 获取用户信息](https://blog.csdn.net/neweastsun/article/details/79337478)  
> [springboot+druid+mybatis plus的多数据源配置](https://cloud.tencent.com/developer/article/1181415)  
> [Redis高级客户端Lettuce详解 ](https://www.cnblogs.com/throwable/p/11601538.html)



---



